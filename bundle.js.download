import { UserDataRequest, FetchTimeoutError } from 'https://assets.acdn.no/pkg/@amedia/user/v0/user.js';
import { getBrowserId } from 'https://assets.acdn.no/pkg/@amedia/browserid/v1/index.js';

const isDebugEnabled = () => window.location.href.indexOf('debug=true') !== -1;

/**
 *  Console logs with a Bazaar prefix when ?debug=true is in the URL.
 *  Tip: Add a (Bazaar) filter in your developer console to only show the Bazaar log.
 */
function debug(...data) {
    if (isDebugEnabled() && data.length > 0) {
        const sinceStart = Date.now() - window.bazaarLoadStart;
        data[0] = `(Bazaar) ${data[0]} [Time: ${sinceStart}ms]`;
        console.log(...data);
    }
}

const queryStrToObj = function queryStrToObj(str) {
	return str.split('&').reduce(
		function(memo, pair) {
			let vals = pair.split('=');
			memo[vals[0]] = vals[1];
			return memo;
		}, {});
};

const getUserAccess = function(cookieValue){
  if (!cookieValue){
    return;
  }
  return queryStrToObj(cookieValue).a_sub_status === 'active';
};

const readCookie = function (name, {doc = document} = {}) {
	let value = "; " + doc.cookie;
	let parts = value.split("; " + name + "=");
	if (parts.length == 2) return parts.pop().split(";").shift();
	return "";
};

/* jshint node:true */

const userLogin = readCookie('daxsub', {});

function isDivCollapsed() {
    return new Promise(((resolve) => {
        document.addEventListener('DOMContentLoaded', () => {
            let element = document.createElement('div');
            element.innerHTML = '&nbsp;';
            element.className = 'ads adsbox';
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';
            element.style.width = '1px';
            element.style.height = '1px';

            document.body.appendChild(element);

            window.setTimeout(() => {
                resolve(element.offsetHeight === 0);
                if (element.remove === undefined) return element.parentElement.removeChild(element);
                return element.remove();
            }, 100);
        });
    }));
}
function isAdsJsBlocked() {
    return fetch('/api/bazaar/v2/ad/adsbygoogle.js')
        .then(() => false).catch(() => true);
}

// This is just a simple shim we need because bazaar loads before adp logger.
function logToAdp(obj) {
    window.addEventListener('message', function initializedListener(evt) {
        if (!evt.data || evt.data.adpEventName !== 'seshat-alive') {
            return;
        }

        window.removeEventListener('message', initializedListener);
        window.postMessage(obj, '*');
    });

    window.postMessage({ adpEventName: 'seshat-ping' }, '*');
}

Promise.all([isAdsJsBlocked(), isDivCollapsed()])
    .then((result) => {
        let detected = !(result.indexOf(true) === -1);

        logToAdp({
            adpEventName: 'seshat-add',
            data: {
                a_adblock: detected,
            },
        });

        debug('Detected AdBlocker: ', detected);
        if (userLogin !== '') {
            debug('Detected UserLogin: daxsub cookie created');
        }
    })
    .catch(err => debug(err));

let consent = true;
let cmpReady = false;

const getConsentObject = new Promise((resolve, reject) => {
    let xobj = new XMLHttpRequest();
    xobj.overrideMimeType('application/json');
    xobj.open('GET', 'https://services.api.no/api/bazaar/v2/iab/consent.json', true);
    xobj.onreadystatechange = function () {
        if (xobj.readyState === 4 && parseInt(xobj.status, 10) === 200) {
            resolve(xobj.responseText);
        }
    };
    xobj.onerror = () => reject(xobj.statusText);
    xobj.send(null);
});

const getUserData = new UserDataRequest()
    .withAttributes(['privacyPreferences'])
    .fetch(isDebugEnabled() ? { timeout: 1000 } : undefined)
    .catch((e) => {
        if (e instanceof FetchTimeoutError && isDebugEnabled()) {
            // if @amedia/user timeouts and debug is enabled: console error & resolve
            // eslint-disable-next-line no-console
            console.error(e);
        } else {
            throw e;
        }
    });

Promise.all([getUserData, getConsentObject])
    .then(([userData, consentObject]) => {
        if (userData) {
            const { attributes: { privacyPreferences } } = userData;
            consent = (privacyPreferences) 
                ? privacyPreferences.personalizedAds 
                : false;
        }

        const consentJSON = JSON.parse(consentObject);

        if (consent) {
            consentJSON.yes.metadata;
            consentJSON.yes.consentString;
        } else {
            consentJSON.no.metadata;
            consentJSON.no.consentString;
        }
        cmpReady = true;
    })
    .catch(e => console.error(e));

const promisedFn = (pfn, data, counter) =>
    new Promise((resolve, reject) => {
        if (cmpReady) {
            resolve(pfn(data, true));
        } else if (counter < 10) {
            setTimeout(() => { promisedFn(pfn, data, counter + 1); }, 100);
        } else {
            reject('no _cmp availiable');
        }
    });

if (!window.__cmpDISABLED) {
    window.__cmpDISABLED = (method, param, fn) => {
        switch (method) {
        case 'getConsentData':
            promisedFn(fn, null, 0);
            debug('__cmp.getConsentData: IABConsentString is disabled');
            break;
        case 'getVendorConsent':
            promisedFn(fn, null, 0);
            debug('__cmp.getVendorConsents: IABConsentString is disabled');
            break;
        /*case 'getConsentData':
            promisedFn(fn, { consentData: consentString, gdprApplies: true, hasGlobalScope: false }, 0);
            log.debug(`IABConsentString:{ 'consentString': '${consentString}', 'consent': ${consent} }`);
            break;
        case 'getVendorConsents':
            promisedFn(fn, {
                metadata: metaData,
                gdprApplies: true,
                hasGlobalScope: false,
                purposeConsents,
                vendorConsents,
            }, 0);
            log.debug(`IABMetaData:{ 'metaData': '${metaData}' }`);
            break;*/
        case 'ping':
            promisedFn(fn, { gdprAppliesGlobally: false, cmpLoaded: true }, 0);
            break;
        }
    };
}

function setPositionFixed(element) {
    Object.assign(element.style, { top: '0', position: 'fixed' });
}

function resetPositionFixed(element) {
    Object.assign(element.style, { position: 'relative' });
    delete element.style.top;
}

function createDOMPlaceHolder() {
    const placeholderElement = document.createElement('div');
    placeholderElement.setAttribute('data-am-placeholder', 'sticky-placeholder');
    return placeholderElement;
}

/**
 *  Sets the DOM-element to a fixed position.
 *  @param: DOM-element
 */
const _export_stickToTop_ = (elementToStick) => {
    const placeholderElement = createDOMPlaceHolder();
    elementToStick.parentNode.insertBefore(placeholderElement, elementToStick);

    const callback = (entries) => {
        entries.forEach(entry => {
            if (entry.target.nextSibling === elementToStick) {
                entry.boundingClientRect.top >= 0
                    ? resetPositionFixed(elementToStick)
                    : setPositionFixed(elementToStick);
            }
        });
    };

    const observer = new IntersectionObserver(callback);
    observer.observe(placeholderElement);
};

let viewWidth = 0;
function isMobile() {
    if (viewWidth === 0) {
        viewWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return viewWidth < 768;
}

const articleURLPattern = /(\d+-\d+-.*|\d+\.html)$/;

const _export_isArticle_ = articleURLPattern.test(window.location.pathname);
const _export_isNettavisen_ = window.location.href.indexOf('nettavisen.no') > -1;
const _export_isExtern_ = 'internal';

const runPopup = (cfg) => {
    const conf = {
        title: '',
        text: cfg.questbackPopupText,
        autoDisplay: true,
        delay: 0.5,
        displayFraction: parseFloat(cfg.questbackPopupFrequency),
        activePeriodStart: undefined,
        activePeriodEnd: undefined,
        buttons: [
            {
                type: 'participate',
                text: 'JA, jeg deltar'
            },
            {
                type: 'decline',
                text: 'Nei takk'
            },
        ],
        width: 500,
        height: 'auto',
        left: '50%',
        top: '50%',
        display: {
            type: 'tab',
            width: 800,
            height: 600
        },
        theme: {
            shadow: true,
            backdrop: false,
            buttonAlignment: 'center',
            showAnimation: {
                type: 'fade-in',
                duration: 500,
                css: undefined
            },
            hideAnimation: {
                type: 'fade-out',
                duration: 500,
                css: undefined
            },
        },
        disableCookies: false,
        cookieName: undefined,
        redisplayAfterDays: 365
    };
    const el = document.createElement('script');
    el.setAttribute('src', 'https://services.api.no/api/bazaar/assets/v2/questback.popup-1.0.1.js');
    el.addEventListener('load', () => {
        questback.popup.create(cfg.questbackPopupLink, conf);
    });
    document.getElementsByTagName('script')[0].parentNode.appendChild(el);
};

window.bazaartag = {};

let DISPLAY_TIMEOUT = 5000;

let slots = [];

let turnOffSingleRequestMode = false;

let takeoverDisplayed = false;
let topbannerSpecialFormatDisplayed = false;

(function singleRequestMode() {
    if (window.location.href.indexOf('singlerequest=false') > -1) {
        turnOffSingleRequestMode = true;
    } else if (window.location.href.indexOf('singlerequest=true') > -1) {
        turnOffSingleRequestMode = false;
    } else if (window.location.href.indexOf('www.nettavisen.no') > -1) {
        turnOffSingleRequestMode = true;
    }
}());

window.bazaartag.initialize = function () {
    debug('Initialize GPT implementation');
    window.googletag = window.googletag || {};
    window.googletag.cmd = window.googletag.cmd || [];
};

window.bazaartag.setTakeoverDisplayed = function () {
    debug('googletag: takeover displayed true');
    takeoverDisplayed = true;
};

window.bazaartag.isTakeoverDisplayed = function () {
    debug('googletag: isTakeoverDisplayed', takeoverDisplayed);
    return takeoverDisplayed;
};

window.bazaartag.setTopbannerSpecialFormatDisplayed = function () {
    debug('googletag: topbannerSpecialFormatDisplayed displayed true');
    topbannerSpecialFormatDisplayed = true;
};

window.bazaartag.isTopbannerSpecialFormatDisplayed = function () {
    debug('googletag: isTopbannerSpecialFormatDisplayed', topbannerSpecialFormatDisplayed);
    return topbannerSpecialFormatDisplayed;
};

window.bazaartag.setTargeting = function (key, value) {
    debug(`googletag: setTargeting(${key}, ${value})`);
    window.googletag.pubads().setTargeting(key, value);
};

function refreshSlot(slotId) {
    let refreshSlot = [slots[slotId]];
    debug('googletag: refreshing slot', refreshSlot);
    window.googletag.pubads().refresh(refreshSlot);
}


function verifyDisplayIsCalled(slotId) {
    let displayed = false;
    document.addEventListener(`display:${slotId}`, (e) => {
        debug(`googletag: display(${slotId}) was called successfully`);
        displayed = true;
    });

    debug(`googletag: display:${slotId} check, adding timeout after ${DISPLAY_TIMEOUT}ms`);

    setTimeout(() => {
        if (!displayed) {
            debug(`googletag: display(${slotId}) was not called successfully, refreshing slot`);
            refreshSlot(slotId);
        }
    }, DISPLAY_TIMEOUT);
}

window.bazaartag.display = function (slotId) {
    debug(`googletag: display(${slotId})`);
    if (takeoverDisplayed && slotId.indexOf('chatbox') > -1) {
        debug('googletag: chatbox not displayed because takeover is displayed');
        return;
    }
    window.googletag.display(slotId);

    verifyDisplayIsCalled(slotId);

    if (turnOffSingleRequestMode) {
        refreshSlot(slotId);
    }
};

window.bazaartag.refresh = function (slotId) {
    let refreshSlot = [slots[slotId]];
    debug('googletag: refreshing slot', refreshSlot);
    window.googletag.pubads().refresh(refreshSlot);
};

window.bazaartag.addEventListener = function (eventId, eventFn) {
    debug(`googletag: addEventListener(${eventId})`, eventFn);
    window.googletag.pubads().addEventListener(eventId, eventFn);
};

window.bazaartag.pauseAdServer = function () {
    debug('googletag: disableInitialLoad');
    window.googletag.pubads().disableInitialLoad();
};

window.bazaartag.enableServices = function () {
    debug('googletag: enableServices');
    if (!turnOffSingleRequestMode) {
        debug('googletag: using single request mode');
        window.googletag.pubads().enableSingleRequest();
    } else {
        debug('googletag: single request mode disabled');
    }
    window.googletag.pubads().setCentering(true);
    window.googletag.enableServices();
};

window.bazaartag.defineOutOfPageSlot = function (slotOptions) {
    const { url, slotId } = slotOptions;
    let outOfPageSlot = window.googletag.defineOutOfPageSlot(url, slotId);
    debug('googletag: defineOutOfPageSlot', outOfPageSlot);
    slots[slotId] = outOfPageSlot;
    return outOfPageSlot;
};

window.bazaartag.defineSlot = function (slotOptions) {
    const { url, size, slotId } = slotOptions;
    let slot = window.googletag.defineSlot(url, size, slotId);
    debug(`googletag: defineSlot(${url}, ${size}, ${slotId})`, slot);
    slots[slotId] = slot;
    return slot;
};

window.bazaartag.sizeMapping = function () {
    let sizeMapping = window.googletag.sizeMapping();
    debug('googletag: sizeMapping', sizeMapping);
    return sizeMapping;
};

window.bazaartag.loadAds = function () {
    if (!turnOffSingleRequestMode) {
        debug('googletag: refresh()');
        window.googletag.pubads().refresh();
    } else {
        debug('googletag: refresh disabled for none single request mode');
    }
};

window.bazaartag.setRequestNonPersonalizedAds = function (request) {
    debug(`googletag: setRequestNonPersonalizedAds(${request})`);
    window.googletag.pubads().setRequestNonPersonalizedAds(request);
};

window.bazaartag.setPublisherProvidedId = function (id) {
    debug(`googletag: setPublisherProvidedId(${id})`);
    window.googletag.pubads().setPublisherProvidedId(id);
};

window.bazaartag.setSlotTargeting = function (slot, slotTargeting) {
    debug(`googletag: setSlotTargeting(slot, ${slotTargeting.keywords}, ${slotTargeting.position}, ${slotTargeting.positionIndex}, ${slotTargeting.threshold})`, slot);
    slot.addService(window.googletag.pubads())
        .setTargeting('keyword', slotTargeting.keywords)
        .setTargeting('position', slotTargeting.positionIndex)
        .setTargeting('format', slotTargeting.position)
        .setTargeting('threshold', slotTargeting.threshold)
        .setTargeting('demandmanager1', 'demandmanager1')
        .setCollapseEmptyDiv(true);
};

window.bazaartag.defineSizeMapping = function (slot, sizeMapping) {
    slot.defineSizeMapping(sizeMapping);
};

window.bazaartag.isReady = function () {
    let ready = !(window.googletag.defineSlot === undefined || !window.googletag.apiReady);
    debug('googletag: isReady', ready);
    return ready;
};

window.bazaartag.cmd = {};

window.bazaartag.cmd.push = function (fn) {
    window.googletag.cmd.push(fn);
};

window.bazaartag.setTargetingPrebid = function () {
    window.pbjs.setTargetingForGPTAsync();
};

if (window.performance) {
    debug(`REQUIRE_DEBUG: end (inside) of gpt-service ts: ${window.performance.now()}`);
}

// @ts-nocheck

const keywordUrlPattern = /keyword=([0-9a-zA-ZæøåÆØÅ, \-_]+)/;

let resolve$1;

const isWallDisplay = window.location.href.indexOf('walldisplay=true') !== -1;

const ready = new Promise((_resolve) => {
    resolve$1 = _resolve;
});

const articlePositions = {
    small: {
        nettavisen: {
            static: ['chatbox', 'takeover'],
            dynamic: ['midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner'],
        },
        default: {
            static: [],
            dynamic: ['midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner', 'midtbanner'],
        },
    },
    large: {
        nettavisen: {
            static: ['chatbox', 'takeover', 'toppbanner', 'skyskraper', 'skyskraper', 'skyskraper', 'skyskraper'],
            dynamic: ['netboard', 'netboard', 'netboard', 'netboard', 'netboard', 'netboard'],
        },
        default: {
            static: ['toppbanner', 'skyskraper', 'artikkelboard'],
            dynamic: ['netboard'],
        },
    },
};

function getPositions(body) {
    const publication = body.publicationName || document.location.hostname;
    const positions = body.positions || body.preload || [];
    if (!_export_isArticle_) {
        // currently we only support predefined positions for articles. Frontpage/section page will follow
        return {
            static: positions,
            dynamic: [],
        };
    }

    const ads = window.innerWidth && window.innerWidth < 767 ? articlePositions.small : articlePositions.large;

    if (publication.toLowerCase().indexOf('nettavisen') !== -1) {
        return ads.nettavisen;
    }
    return ads.default;
}

function parseText(text) {
    try {
        return JSON.parse(text);
    } catch (e) {
        debug('Could not parse Bazaar configuration as json. Evaluated as empty.', text);
        return {};
    }
}

/**
 *   Assigns default values and returns the config.
 */
function buildConfig(body) {
    const predefinedPositions = getPositions(body);
    const positions = [...predefinedPositions.static, ...predefinedPositions.dynamic];
    const publication = body.publication !== undefined ? body.publication : document.location.hostname;

    let thresholdValueToppbanner = '200';
    let thresholdValueMidtbanner = '200';
    let thresholdValueNetboard = '200';

    if (publication.indexOf('www.nettavisen.no') > -1) {
        thresholdValueMidtbanner = '400';
        thresholdValueNetboard = '400';
    }

    debug(`Threshold set to ${thresholdValueToppbanner} for toppbanner, ${thresholdValueMidtbanner} for midtbanner and ${thresholdValueNetboard} for netboard`);

    const config = {
        publication: publication,
        publicationName: body.publicationName || document.location.hostname,
        titleCode: body.title_code || '',

        slotUrl: '/56257416/{publication}/{position}',

        audiencePixelUrl: 'https://pubads.g.doubleclick.net/activity;dc_iu=/56257416/DFPAudiencePixel;ord={ord};dc_seg={segment}',

        mobileToppbanner: thresholdValueToppbanner,
        mobileMidtbanner: thresholdValueMidtbanner,
        mobileNetboard: thresholdValueNetboard,
        desktopToppbanner: thresholdValueToppbanner,
        desktopMidtbanner: thresholdValueMidtbanner,
        desktopNetboard: thresholdValueNetboard,
        desktopArtikkelboard: '-100',
        desktopSkyskraper: '0',
        takeover: '100',
        keywords: body.keywords !== undefined
            ? body.keywords
            : [],

        positions,
        dynamicPositionOrder: predefinedPositions.dynamic,
        localLazyLoad: body.localLazyLoad !== undefined
            ? body.localLazyLoad
            : false,
        categories: document.getElementsByName('categories').length > 0
            ? [`${document.getElementsByName('categories')[0].getAttribute('content')}`]
            : [],
        questbackPopupActive: body['questback.popup.active'] !== undefined && body['questback.popup.active'] !== 'false',
        questbackPopupFrequency: body['questback.popup.frequency'] !== undefined
            ? body['questback.popup.frequency']
            : '',
        questbackPopupLink: body['questback.popup.link'] !== undefined
            ? body['questback.popup.link']
            : '',
        questbackPopupText: body['questback.popup.text'] !== undefined
            ? body['questback.popup.text']
            : '',
    };

    const urlKeywords = window.location.href.match(keywordUrlPattern);
    if (urlKeywords) {
        config.keywords = config.keywords.concat(urlKeywords[1].split(','));
    }

    if (isWallDisplay) {
        config.publication = 'www.salsaposten.no';
        config.keywords.push('walldisplay');
    }

    if (/pushvarslings-app/i.test(navigator.userAgent)) {
        config.keywords.push('pushapp');
    }

    const viewWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
    if (viewWidth < 1375) {
        debug('Viewport is under 1375px, removing skyskraper from config');
        config.positions = config.positions.filter(pos => pos.indexOf('skyskraper') === -1);
    }
    return config;
}

class bazaarConfig extends HTMLElement {
    /**
     *  Returns the content found in the first bazaarscript as text.
     */
    getScriptBody() {
        const bazaarScripts = [].slice.call(this.getElementsByTagName('script'))
            .filter((script) => script.getAttribute('type') === 'application/bazaarscript');

        return bazaarScripts && bazaarScripts.length > 0
            ? bazaarScripts[0].textContent
            : undefined;
    }

    connectedCallback() {
        // Timeout because of safari not ready
        setTimeout(() => this.init(), 1);
    }

    attachedCallback() {
        this.init();
    }

    init() {
        window.bazaartag = window.bazaartag || {};
        window.bazaartag.cmd = window.bazaartag.cmd || [];

        window.bazaartag.initialize();

        const body = this.getScriptBody();
        const json = parseText(body);
        const config = buildConfig(json);

        debug('Config ready: ', config);
        resolve$1(config);
        if (config.questbackPopupActive) {
            runPopup(config);
        }
    }
}

if (customElements && customElements.define) {
    customElements.define('bazaar-config', bazaarConfig);
} else {
    // @ts-ignore
    document.registerElement('bazaar-config', {
        prototype: bazaarConfig.prototype,
    });
}

var config$2 = () => ready;

function getMidtbannerId() {
    if (isMobile()) {
        return 'mobilbanner';
    }
    return 'midtbanner';
}

function getMidtbannerRangeSize() {
    if (isMobile()) {
        return {
            min: [200, 50],
            max: [null, 480],
        };
    }
    return {
        min: [700, 50],
        max: [980, 600],
    };
}


/**
 *  Mapping containing:
 *  1) minHeight for giving default css min-height the ad
 *  2) a fallback size and lookup sizes for each position used when fetching ads from DFP
 *  through the Google Publisher Tag library. Any position not mapped will return as false.
 *
 *  https://developers.google.com/doubleclick-gpt/reference#googletag.defineSlot
 */
function mapping(position) {
    const desktopBreakpoint = [768, 0];
    const mobileBreakpoint = [0, 0];
    switch (position) {
    case 'instream':
        return {
            prebid: {
                use: true,
            },
        };
    case 'toppbanner':
        return {
            minHeight: {
                mobile: 250,
                desktop: 300,
            },
            rangeSize: {
                max: [980, 300],
                min: [700, 50],
            },
            prebid: {
                use: true,
                native: false,
                banner: true,
                video: false,
            },
            size: ['fluid'],
            breakpoints: [
                { break: [[768, 0], [[980, 120], [980, 150], [980, 200], [980, 240], [980, 300], [1000, 150], [1000, 300], 'fluid']] },
                { break: [mobileBreakpoint, [[300, 250], [320, 250]]] },
            ],
        };
    case 'toppbannerdods':
        return {
            minHeight: {
                mobile: 250,
                desktop: 300,
            },
            prebid: {
                use: false,
            },
            size: [300, 250],
            breakpoints: [
                { break: [[768, 0], [[980, 120], [980, 150], [980, 200], [980, 240], [980, 300]]] },
                { break: [mobileBreakpoint, [[300, 250], [320, 250]]] },
            ],
        };
    case 'skyskraperdods':
        return {
            minHeight: {
                mobile: 500,
                desktop: 500,
            },
            prebid: {
                use: false,
            },
            size: [181, 500],
            breakpoints: [
                { break: [[1300, 250], [[180, 500], [250, 500], [300, 600]]] },
                { break: [mobileBreakpoint, []] },
            ],
        };
    case 'skyskrapervenstre':
        return {
            minHeight: {
                mobile: 500,
                desktop: 500,
            },
            prebid: {
                use: false,
            },
            size: [181, 500],
            breakpoints: [
                { break: [[1300, 250], [[181, 500], [181, 700]]] },
                { break: [mobileBreakpoint, []] },
            ],
        };
    case 'midtbanner':
        return {
            minHeight: {
                mobile: 250,
                desktop: 300,
            },
            rangeSize: getMidtbannerRangeSize(),
            prebid: {
                use: true,
                native: true,
                banner: true,
                video: true,
                placementId: getMidtbannerId(),
            },
            size: ['fluid'],
            breakpoints: [
                { break: [desktopBreakpoint, [[980, 120], [980, 150], [980, 200], [980, 240], [980, 300], [980, 500], [980, 600], [1920, 1080], 'fluid']] },
                { break: [mobileBreakpoint, [[300, 250], [320, 250], [320, 400], [320, 480], [300, 300], [1920, 1080], 'fluid']] },
            ],
        };
    case 'netboard':
        return {
            minHeight: {
                mobile: 250,
                desktop: 500,
            },
            rangeSize: {
                max: [580, 500],
                min: [300, 250],
            },
            prebid: {
                use: true,
                native: true,
                banner: true,
                video: true,
            },
            size: ['fluid'],
            breakpoints: [
                { break: [desktopBreakpoint, [[480, 400], [580, 400], [580, 500], 'fluid']] },
                { break: [mobileBreakpoint, [[300, 250], [320, 250], [320, 480], [320, 400], [300, 300]]] },
            ],
        };
    case 'netboarddm':
    case 'netboardsmb':
        return {
            minHeight: {
                mobile: 250,
                desktop: 500,
            },
            prebid: {
                use: false,
            },
            size: [580, 500],
            breakpoints: [
                { break: [desktopBreakpoint, [[480, 400], [580, 400], [580, 500]]] },
                { break: [mobileBreakpoint, []] },
            ],
        };
    case 'skyskraper':
        return {
            minHeight: {
                mobile: 500,
                desktop: 500,
            },
            rangeSize: {
                max: [320, 1050],
                min: [100, 400],
            },
            prebid: {
                use: true,
                native: false,
                banner: true,
                video: false,
            },
            size: [180, 500],
            breakpoints: [
                { break: [[1300, 250], [[180, 500], [160, 600], [180, 700]]] },
                { break: [[1450, 250], [[180, 500], [160, 600], [180, 700], [250, 500], [280, 500], [300, 600], [300, 250], [320, 250], [320, 400], [320, 480], [300, 300]]] },
                { break: [mobileBreakpoint, []] },
            ],
        };
    case 'artikkelboard':
        return {
            minHeight: {
                mobile: 250,
                desktop: 250,
            },
            rangeSize: {
                max: [320, 300],
                min: [200, 125],
            },
            prebid: {
                use: true,
                native: true,
                banner: true,
                video: true,
            },
            size: ['fluid'],
            breakpoints: [
                { break: [desktopBreakpoint, [[320, 250], [300, 250], 'fluid']] },
                { break: [mobileBreakpoint, []] },
            ],
        };
    case 'outstreamvideo':
        return {
            minHeight: {
                mobile: 1,
                desktop: 1,
            },
            prebid: {
                use: false,
            },
            size: [1, 1],
            breakpoints: [
                { break: [desktopBreakpoint, [[1, 1]]] },
                { break: [mobileBreakpoint, [[1, 1]]] },
            ],
        };
    case 'midtbannersmb':
        return {
            minHeight: {
                mobile: 250,
                desktop: 250,
            },
            prebid: {
                use: false,
            },
            size: [320, 250],
            breakpoints: [
                { break: [desktopBreakpoint, [[980, 120], [980, 150], [980, 200], [980, 240], [980, 300], [980, 500], [980, 600], 'fluid']] },
                { break: [mobileBreakpoint, [[300, 250], [320, 250], [320, 400], [320, 480], 'fluid']] },
            ],
        };
    case 'cm':
    case 'cm1':
    case 'cm2':
        return {
            minHeight: {
                mobile: 250,
                desktop: 250,
            },
            prebid: {
                use: true,
                native: true,
                banner: false,
                video: false,
            },
            size: 'fluid',
            breakpoints: [
                { break: [desktopBreakpoint, 'fluid'] },
                { break: [mobileBreakpoint, 'fluid'] },
            ],
        };
    case 'chatbox':
        return {
            minHeight: {
                mobile: 1,
                desktop: 1,
            },
            prebid: {
                use: false,
            },
            size: [1, 1],
            breakpoints: [
                { break: [desktopBreakpoint, [[240, 133], [1, 1], [10, 10]]] },
                { break: [mobileBreakpoint, [[240, 133], [1, 1], [10, 10]]] },
            ],
        };
    case 'takeover':
        return {
            prebid: {
                use: false,
            },
            size: [1920, 1080],
        };
    default:
        return false;
    }
}

const createSlot$1 = (slotInfo) => {
    const { url, sizeMapping, slotId, position, id, publication } = slotInfo;
    let size = sizeMapping.size;
    let rangeSize = sizeMapping.rangeSize;
    if (rangeSize) {
        size = {
            fixed: sizeMapping.size,
            min: rangeSize.min,
            max: rangeSize.max,
        };
        debug(`Adding range size for ${position}`, size);
    }
    let slot = window.bazaartag.defineSlot({ url, size, slotId, position, publication });
    debug('Load slot', slot);

    if (!slot) {
        console.error(`Error getting slot for ${position}, id=${id} slotId=${slotId}, size ${size}, url ${url}`);
        return false;
    }
    const map = window.bazaartag.sizeMapping();

    if (map && sizeMapping.breakpoints !== undefined) {
        for (const prop in sizeMapping.breakpoints) {
            const value = sizeMapping.breakpoints[prop];
            map.addSize(value.break[0], value.break[1]);
        }
        window.bazaartag.defineSizeMapping(slot, map.build());
    }
    return slot;
};

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var userUUID = () => {
    let pageviewIdTag = document.querySelector('meta[name="adpPageviewId"]');
    let pageviewId;
    if (!pageviewIdTag) {
        const tag = document.createElement('meta');
        tag.name = 'adpPageviewId';
        tag.content = v4();
        document.head.appendChild(tag);
        pageviewId = tag.content;
    } else {
        pageviewId = pageviewIdTag.content;
    }

    return pageviewId;
};

/**
 * Styles bazaar-element if page requested with query-parameter google_nofetch=true or google_nofetch=1
 * @param bazaarAdId of bazaar-element to style
 */
const _export_setStylingIfNoFetch_ = function (bazaarAdId) {
    const fetchNoAds = window.location.href.indexOf('google_nofetch') !== -1;
    const renderNoAds = window.location.href.indexOf('google_norender') !== -1;

    if (fetchNoAds || renderNoAds) {
        const bazaarAd = document.getElementById(bazaarAdId);
        if (bazaarAd.classList) {
            bazaarAd.classList.add('am-bazaar-ad--noad');
        } else {
            bazaarAd.className = 'am-bazaar-ad--noad';
        }
        const positionElement = document.createElement('div');
        positionElement.innerHTML = bazaarAdId;
        bazaarAd.insertBefore(positionElement, bazaarAd.firstChild);
    }
};

const isEnabled$1 = typeof window !== 'undefined' &&
    window.performance &&
    window.performance.timing.fetchStart !== undefined;

const start = isEnabled$1
    ? window.performance.timing.fetchStart
    : undefined;

/**
 *  Returns elapsed time in milliseconds since page load.
 */
function elapsed() {
    return isEnabled$1
        ? Date.now() - start
        : undefined;
}

const showPrebidInfo = window.location.href.indexOf('prebid_show=true') !== -1;
let _table;
let _overlay;

function resultLogging(info, args, data) {
    let tr = document.createElement('tr');
    let tdinfo = document.createElement('td');
    let tdargs = document.createElement('td');
    tr.appendChild(tdinfo);
    tr.appendChild(tdargs);
    tdinfo.innerHTML = info;
    if (args !== undefined) {
        tdargs.innerHTML = args;
    }
    _table.appendChild(tr);

    _overlay.scrollTop = _overlay.scrollHeight;

    if (data !== undefined) {
        debug(info, data);
    }

}

function createOverlay() {
    _overlay = document.createElement('div');
    _overlay.id = 'bazaar-debug-overlay';
    _table = document.createElement('table');
    _overlay.appendChild(_table);
    document.body.appendChild(_overlay);
}

const init$2 = () => {
    if (showPrebidInfo) {
        createOverlay();
        window.pbjs.onEvent('addAdUnits', () => {
            resultLogging('Prebid adUnits', window.pbjs.adUnits.map(au => au.code));
        });
        window.pbjs.onEvent('auctionInit', (data) => {
            resultLogging('Auction start', `Timeout: ${data.timeout}ms`, data);
        });
        window.pbjs.onEvent('auctionEnd', () => {
            resultLogging('Auction ended');
        });
        window.pbjs.onEvent('bidRequested', (data) => {
            resultLogging('Bid requested', `${data.bidderCode} ${data.gdprConsent && data.gdprConsent.consentString ? '(ConsentString is set)' : '(ConsentString is NOT set)'}`, data);
        });
        window.pbjs.onEvent('bidResponse', (data) => {
            resultLogging('Bid response', `${data.bidderCode} - ${data.adUnitCode} (${data.width}x${data.height}) - ${data.mediaType} - ${data.cpm} NOK`, data);
        });
        window.pbjs.onEvent('bidderDone', (data) => {
            resultLogging('Bidder done', data.bidderCode, data);
        });
        window.pbjs.onEvent('requestBids', () => {
            resultLogging('Requesting bids');
        });
        window.pbjs.onEvent('bidTimeout', (data) => {
            resultLogging('Bid timeout', data.map(b => b.bidder).filter((v, i, a) => a.indexOf(v) === i).join(', '), data);
        });
    }
};

const bidWon = () => {
    if (showPrebidInfo) {
        window.pbjs.onEvent('bidWon', (data) => {
            resultLogging('Bid won', `${data.bidderCode} - ${data.adUnitCode} (${data.width}x${data.height}) - ${data.mediaType} - ${data.cpm} NOK`, data);
        });
    }
};

const isPrebidDisabled = window.location.href.indexOf('prebid_disable=true') !== -1;

let adUnits = [];
let instreamAdUnit;
let PREBID_TIMEOUT = 2000;
let config$1;
let prebidDone = false;
let displayCalledBeforePrebidDone = [];
let instreamAdUnitKeywords;

// Do not call display before prebid is done
function callDelayedDisplay() {
    for (let i = 0; i < displayCalledBeforePrebidDone.length; i += 1) {
        const inViewportObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                displayCalledBeforePrebidDone[i].refreshFunction();
                if (entry.intersectionRatio > 0) {
                    debug(
                        `prebid: ${displayCalledBeforePrebidDone[i].id} is in viewport, calling delayed display`,
                    );
                    displayCalledBeforePrebidDone[i].displayFunction();
                    inViewportObserver.disconnect();
                } else {
                    // The user scrolled pass the ad before prebid was done
                    debug(
                        `prebid: ${displayCalledBeforePrebidDone[i].id} is no longer in the viewport, skip delayed display`,
                    );
                }
            });
        });
        inViewportObserver.observe(
            document.querySelector(
                `bazaar-ad[id="${displayCalledBeforePrebidDone[i].id}"]`,
            ),
        );
    }
}
function triggerPrebidInstreamEvent(targeting) {
    const prebidInstreamDone = new CustomEvent('prebid:instream_done', {});
    prebidInstreamDone.data = {
        adServerTargeting: targeting,
    };
    debug(
        'prebid instream: sending prebid:instream_done',
        prebidInstreamDone,
    );
    window.dispatchEvent(prebidInstreamDone);
    window.addEventListener('prebid:resend_if_done', () => {
        debug('prebid instream: sending prebid:resend_if_done');
        window.dispatchEvent(prebidInstreamDone);
    });
}

function sendVideoAdserverRequest(bidResponses, timedOut, auctionId) {
    debug('prebid instream: Returning from instream request', bidResponses, timedOut, auctionId);
    let targeting = {};
    if (config$1.positions.indexOf('instream') > -1 && bidResponses) {
        let cpm = 0;
        Object.entries(bidResponses).forEach(([key, value]) => {
            if (value.bids && value.bids.length > 0) {
                value.bids.forEach(bid => {
                   if (bid.cpm > cpm) {
                       targeting = bid.adserverTargeting;
                       cpm = bid.cpm;
                   }
                });
                debug('prebid instream: Got instream adserverTargeting', targeting);
            }

        });
    }
    if (instreamAdUnitKeywords && instreamAdUnitKeywords.length > 0) {
        targeting.keyword = instreamAdUnitKeywords.join(',');
    }

    triggerPrebidInstreamEvent(targeting);
}

function sendAdserverRequest(bidResponses, timedOut, auctionId) {
    if (window.pbjs.adserverCalled) {
        debug('prebid: Prebid Adserver request already sent');
        return;
    }
    debug('prebid: Sending Prebid Adserver request', adUnits, bidResponses, timedOut, auctionId);
    window.pbjs.adserverCalled = true;
    window.pbjs.que.push(() => {
        debug('prebid: Returned from Prebid');
        bidWon();
        window.pbjs.setTargetingForGPTAsync();
        prebidDone = true;
        callDelayedDisplay();
    });
}

function setAdUnits(ads) {
    adUnits = ads.reduce((prev, ad) => {
        if (ad.prebidAdUnit && ad.prebidAdUnit.code !== 'ad-instream-1') {
            prev.push(ad.prebidAdUnit);
        }
        return prev;
    }, []);
    ads.forEach((ad) => {
        if (ad.prebidAdUnit && ad.prebidAdUnit.code === 'ad-instream-1') {
            instreamAdUnit = ad.prebidAdUnit;
        }
    });
}

function initPrebid(ads, targeting) {
    if (isPrebidDisabled) {
        debug('prebid: prebid is disabled');
        prebidDone = true;
        return false;
    }
    setAdUnits(ads);

    if (adUnits.length === 0) {
        debug('prebid: No prebid adunits found, exiting prebid');
        prebidDone = true;
        return false;
    }

    debug('prebid: Prebid adunit config and targeting', adUnits, targeting);
    window.pbjs = window.pbjs || {};
    window.pbjs.que = window.pbjs.que || [];

    // request pbjs bids when it loads
    window.pbjs.que.push(() => {
        init$2();
        // TODO: Add adplogger as analytics
        // window.pbjs.enableAnalytics([{ provider: 'adplogger' }]);

        let requestBids = {
            callback: sendAdserverRequest,
            gptSlotObjects: adUnits,
            timeout: PREBID_TIMEOUT,
            data: targeting,
            // sizeMappings: 'defineres i GUI'et istedet for å sende inn her. da kan adops selv konfigurere ting der'
        };
        debug('prebid: Requesting ads for adunits', requestBids);
        window.pbjs.rp.requestBids(requestBids);

        if (instreamAdUnit) {
            instreamAdUnitKeywords = targeting.keywords;
            let viewBidRequest = {
                adSlotName: instreamAdUnit.getAdUnitPath(),
                adServer: 'override',
                playerSize: [640, 360],
                callback: sendVideoAdserverRequest,
                data: targeting,
            };
            debug('prebid: Requesting instream ads', viewBidRequest);
            window.pbjs.rp.requestVideoBids(viewBidRequest);
        }
    });

    debug('prebid: Setting prebid timeout ms', PREBID_TIMEOUT);

    setTimeout(() => {
        sendAdserverRequest(adUnits);
    }, PREBID_TIMEOUT);

    debug('prebid: Prebid init done');
    return true;
}

function isPrebidInUse(sizeMapping) {
    return sizeMapping.prebid !== undefined && sizeMapping.prebid.use;
}

function createAdunit(slotInfo) {
    const { sizeMapping, slotId: id, position, conf, prebidConfig } = slotInfo;
    if (!isPrebidInUse(sizeMapping) || isPrebidDisabled) {
        return null;
    }
    config$1 = conf;

    debug(`prebid: creating prebid adunit for id ${id}, keywords ${prebidConfig.keywords}`,prebidConfig);

    let adUnit = {};
    adUnit.code = id;
    adUnit.mediaTypes = {};
    adUnit.getAdUnitPath = () => prebidConfig.url;
    adUnit.getSlotElementId = () => id;
    adUnit.getSizes = () => [];

    if (sizeMapping.prebid.banner) {
        debug(`prebid: adding prebid banner mediatype for ${position}`);
        addBannerMediaType();
    }
    if (sizeMapping.prebid.native) {
        debug(`prebid: adding prebid native mediatype for ${position}`,adUnit);
        addNativeMediaType();
    }
    if (sizeMapping.prebid.video) {
        debug(`prebid: adding prebid video mediatype for ${position}`);
        addVideoMediaType();
    }
    debug(`prebid: Prebid adunit for ${position} created`, adUnit);
    return adUnit;


    function addVideoMediaType() {
        adUnit.mediaTypes.video = {
            context: 'outstream',
            playerSize: [640, 480],
        };
    }

    function addNativeMediaType() {
        adUnit.mediaTypes.native = {
            image: {
                required: true,
                aspect_ratios: [
                    {
                        ratio_width: 1.91,
                        ratio_height: 1,
                    },
                ],
            },
            title: {
                required: true,
                len: 200,
            },
            sponsoredBy: {
                required: true,
            },
            clickUrl: {
                required: true,
            },
        };
    }

    function addBannerMediaType() {
        let desktopSizes = sizeMapping.breakpoints[0].break[1].filter((item) => item !== 'fluid');
        let mobileSizes = sizeMapping.breakpoints[1].break[1].filter((item) => item !== 'fluid');
        const sizes = (isMobile() ? mobileSizes : desktopSizes).concat([[1, 1]]);
        adUnit.getSizes = () => [sizes];
        adUnit.mediaTypes.banner = { sizes };
    }
}

if (!String.prototype.startsWith) {
    // eslint-disable-next-line no-extend-native
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

function callDisplayWhenPrebidDone(displayFunction, refreshFunction, id) {
    if (prebidDone) {
        debug(`prebid: prebid done, call display for ${id}`);
        displayFunction();
        refreshFunction();
    } else {
        debug(`prebid: prebid not done, delay call display for ${id}`);
        displayCalledBeforePrebidDone.push({
            displayFunction: displayFunction,
            refreshFunction: refreshFunction,
            id: id,
        });
    }
}

let runOnlyOnce = true;
const isEnabled = window.location.href.indexOf('showads=true') !== -1;
let adsTable = [];
const dfpLineItem = 'https://www.google.com/dfp/56257416?pli=1#delivery/LineItemDetail/lineItemId=';
const slotVisibilityChanged$1 = 'visualAds-slotVisibilityChanged';
const impressionViewable$1 = 'visualAds-impressionViewable';
const slotOnload = 'visualAds-slotOnload';

const htmlTable = (() => {
    let _toggle = true;
    let _table;
    let _overlay;

    const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;

    // https://stackoverflow.com/questions/14267781/sorting-html-table-with-javascript
    const comparer = (idx, asc) => (a, b) => ((v1, v2) =>
    v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2) ? v1 - v2 : v1.toString().localeCompare(v2)
    )(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));

    const sortByColumIndex = (columnIndex) => {
        const table = document.querySelector('#bazaar-debug-overlay table');
        Array.from(table.querySelectorAll('tr:nth-child(n+2)'))
            .sort(comparer(columnIndex, _toggle = !_toggle))
            .forEach(tr => table.appendChild(tr));
    };

    const tableHeaderSort = () => {
        document.querySelectorAll('#bazaar-debug-overlay th')
            .forEach(th => th.addEventListener('click', (() => {
                sortByColumIndex(Array.from(th.parentNode.children).indexOf(th));
            })));
    };

    const createRows = () => {
        let row;
        const createHeader = (element, totalAds) => {
            Object.entries(element).forEach(([key, value]) => {
                const cell = document.createElement('TH');
                if (value === `${adsTable[0].h1}`) {
                    cell.innerHTML = `${value} (${totalAds})`;
                } else {
                    cell.innerHTML = `${value}`;
                }
                row.appendChild(cell);
            });
        };
        const createRow = (element) => {
            let bazaarAdId = null;
            Object.entries(element).forEach(([key, value], i) => {
                const cell = row.insertCell(-1);
                if (i === 0) {
                    cell.id = `vd-${value}`;
                    bazaarAdId = `${value}`;
                }
                cell.innerHTML = value;
            });
            row.addEventListener('click', () => {
                const removeBorder = (ads) => ads.forEach(el => el.removeAttribute('style'));
                const setBorder = (ad) => ad.setAttribute('style', 'outline: red solid 5px;');
                let bazaarAd = document.getElementById(bazaarAdId);
                if (!bazaarAd) {
                    const position = bazaarAdId.slice(0, bazaarAdId.indexOf('-'));
                    const index = bazaarAdId.slice(bazaarAdId.indexOf('-') + 1);
                    bazaarAd = document.querySelectorAll(`bazaar-ad[position=${position}]`)[index - 1];
                }
                removeBorder(document.querySelectorAll('bazaar-ad'));
                setBorder(bazaarAd);
                bazaarAd.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'end' });
            });
        };
        adsTable.forEach((element, i) => {
            row = _table.insertRow(-1);
            if (i === 0) {
                createHeader(element, adsTable.length - 1);
            } else {
                createRow(element);
            }
        });
    };

    return {
        create: () => {
            _overlay = document.createElement('div');
            _overlay.id = 'bazaar-debug-overlay';
            _table = document.createElement('TABLE');
            createRows();
        },
        appendToDocument: () => {
            _overlay.appendChild(_table);
            document.body.appendChild(_overlay);
            tableHeaderSort();
        },
    };
})();

const createAdsObject = (positions) => {
    const tableHeader = { h1: 'Annonser', h2: 'Viewable', h3: 'Download', h4: 'Dfp Line item', h5: 'In view' };
    adsTable.push(tableHeader);

    let i;
    Object.entries(positions).forEach(([key, value]) => {
        for (i = 1; i < value.nextIndex; i += 1) {
            adsTable.push({
                id: `${key}-${i}`,
                viewable: 'No',
                download: 'No',
                dfp: 'N/A',
                inview: '<span>0</span>&nbsp;%&nbsp;&nbsp;<span>0</span>&nbsp;ms',
            });
        }
    });
};

const createLineItem = (lineItemId, column) => {
    const link = dfpLineItem + lineItemId;
    column.innerHTML = `<a href='javascript:void(0)' onclick='window.open("${link}","_blank")'>Line item</a>`;
};

const updateAd = (eventType, adInfo, domElement) => {
    const id = adInfo.id;
    const index = adsTable.map(e => e.id).indexOf(id);
    if (index !== -1) {
        const col1 = domElement.nextSibling;
        const col2 = col1.nextSibling;
        const col3 = col2.nextSibling;
        const col4 = col3.nextSibling;
        if (eventType === impressionViewable$1) {
            col1.innerHTML = 'YES';
            Object.assign(domElement.parentElement.style, { color: 'green', fontWeight: 'bold' });
            if (adInfo.info !== null && adInfo.info.lineItemId !== null) {
                createLineItem(adInfo.info.lineItemId, col3);
            }
        } else if (eventType === slotOnload) {
            col2.innerHTML = 'YES';
            Object.assign(domElement.parentElement.style, { color: 'green', fontWeight: 'bold' });
            if (adInfo.info !== null && adInfo.info.lineItemId !== null) {
                createLineItem(adInfo.info.lineItemId, col3);
            }
        } else if (eventType === slotVisibilityChanged$1) {
            const spans = col4.getElementsByTagName('span');
            const viewPercent = spans[0];
            const elapsed = spans[1];
            viewPercent.innerHTML = adInfo.inViewPercentage;
            elapsed.innerHTML = adInfo.elapsed;
            if (adInfo.inViewPercentage > 0) {
                Object.assign(domElement.style, { color: 'red' });
            } else {
                Object.assign(domElement.style, { color: 'green' });
                Object.assign(domElement.parentElement.style, { color: 'green', fontWeight: 'bold' });
            }
        }
    }
};

const init$1 = () => {
    if (isEnabled && runOnlyOnce) {
        getAllAds()
            .then(_store => {
                createAdsObject(_store.positions);
                htmlTable.create();
                htmlTable.appendToDocument();
            });
        runOnlyOnce = false;
    }
};

const eventHandler = (eventType, data) => {
    const domElement = document.getElementById(`vd-${data.id}`);
    if (!domElement) return;
    updateAd(eventType, data, domElement);
};

window.addEventListener(impressionViewable$1, (data) => {
    eventHandler(impressionViewable$1, data.detail);
});

window.addEventListener(slotVisibilityChanged$1, (data) => {
    eventHandler(slotVisibilityChanged$1, data.detail);
});

window.addEventListener(slotOnload, (data) => {
    eventHandler(slotOnload, data.detail);
});

// default settings
let adId = 'toppbanner-1';
const shadowPlaceholderId = 'shadow-1';
let adImpressionViewable = false;
let moveForward = false;
let isShadowing = false;
let doShadowing = !isMobile();

let shadowReposition = false;

let shadowRepositionInterval;

// Get an element's distance from the top of the page
let getElemDistance = function (elem) {
    let location = 0;
    if (elem.offsetParent) {
        do {
            location += elem.offsetTop;
            elem = elem.offsetParent;
        } while (elem);
    }
    return location >= 0 ? location : 0;
};


/**
 * The logic for creating the placeholder container for the ad.
 * This containers height is set as big as the ad, as the ad will be overlapping/put on top of it.
 */
const shadow = (function () {
    const shadowElement = 'bazaar-ad[position=\'shadow\']';
    return {
        setUpShadowPlaceholderElement: () => {
            let ad = shadow.getAd();
            if (ad === null) {
                debug('shadow: did not find ad to shadow');
            }
            let shadowPlaceholder = shadow.getShadowPlaceholder();
            if (shadowPlaceholder === null) {
                debug('shadow: did not find shadow placeholder');
            } else {
                shadowPlaceholder.style.display = 'unset';
            }
            if (ad !== null && shadowPlaceholder !== null) {
                debug('shadow: fetching shadow placeholder element', shadowPlaceholder);
                debug(`shadow: starting shadowing for ${adId}`);
                return shadowPlaceholder;
            }
            return null;
        },
        getShadowPlaceholder() {
            return document.querySelector(shadowElement);
        },
        getAd() {
            return document.querySelector(`bazaar-ad[id='${adId}']`);
        },
    };
}());

/**
  * The logic for moving the elements back and forth is handled here.
  * - moveForward:
  * sets css properties of the ads container: top and z-index
  * The top-property will move the element x-number of pixels,
  * so that the element is overlapping the placeholder container.
  *
  * - moveBack:
  * clears the css properties which in turn will move the ad back to its original place
  */
const positioning = (function () {
    return {
        moveForward: () => {
            let ad = shadow.getAd();

            ad.parentNode.style.height = ad.style.height;

            let shadowPlaceholder = shadow.getShadowPlaceholder();

            let rect = shadowPlaceholder.getBoundingClientRect();
            let rect2 = ad.getBoundingClientRect();

            if (rect2.top < rect.top + 20 && rect2.top > rect.top - 20) {
                // log.debug('shadow: position already calculated for shadow element, returning');
                return;
            }

            let height = `${(ad.parentNode.clientHeight + 40)}px`;

            shadowPlaceholder.style.height = height;

            rect = shadowPlaceholder.getBoundingClientRect();

            let ypos = getElemDistance(shadowPlaceholder);

            ad.style.top = `${ypos}px`;
            ad.style.zIndex = 2;

            rect2 = ad.getBoundingClientRect();

            // fine tune position
            while (rect2.top > rect.top + 20) {
                ypos -= 10;
                ad.style.top = `${ypos}px`;
                rect2 = ad.getBoundingClientRect();
            }
        },

        moveBack: () => {
            let ad = shadow.getAd();
            ad.parentNode.style.height = ad.style.height;
            ad.style.top = '';
            ad.style.zIndex = 0;
        },
    };
}());


function checkShouldReposition(entry) {
    if (entry.intersectionRatio === 0) {
        shadowReposition = false;
    } else if (entry.intersectionRatio > 0) {
        shadowReposition = true;
    }
}

/**
 * The heart of shadow placement, the callback handling how the logic is handled.
 * The callback handles logic when:
 * - the shadow placeholder is in viewport
 * - scrolling down into the placeholder -> move ad from original position to overlay placeholder
 * - scrolling up from the placeholder   -> move ad from placeholder to its original position
 * - exiting shadow and cleaning up when inscreen of ad as been accomplished
 * @param entries
 * @param observer
 */
const callback = (entries) => {
    entries.forEach(entry => {
        if (entry.intersectionRatio > 0 && !adImpressionViewable) {
            moveForward = true;
            debug('shadow: shadow placeholder in viewport, no inscreen, move shadowed ad to shadow placeholder');
        } else if (entry.intersectionRatio === 0 && !adImpressionViewable) {
            if (moveForward) {
                moveForward = false;
                debug('shadow: shadow placeholder not in viewport, no inscreen, move shadowed ad back to original position');
                positioning.moveBack();
            }
        } else if ((entry.intersectionRatio === 0 || !moveForward) && adImpressionViewable) {
            let shadowDOMElement = shadow.getShadowPlaceholder();
            let rect = shadowDOMElement.getBoundingClientRect();
            // Move up if scroll up
            if (rect.top > 0) {
                exitShadowing();
            } // leave in place if scroll down to prevent jumping
        }
        checkShouldReposition(entry);
    });
};

const observer = new IntersectionObserver(callback);

function doReposition() {
    shadowRepositionInterval = setInterval(() => {
        if (shadowReposition) {
            if (moveForward) {
                positioning.moveForward();
            }
        }
    }, 1000);
}

const startObserver = (target) => {
    if (target !== null && target !== undefined) {
        doReposition();

        observer.observe(target);
        debug('shadow: start observing shadow element', target);
    } else {
        debug('shadow: could not observe shadow element');
    }
};

const stopObserver = (target) => {
    if (target !== null && target !== undefined) {
        debug(`shadow: stop observing shadow ${adId}`);
        observer.disconnect();
    }
};

const exitShadowing = () => {
    clearInterval(shadowRepositionInterval);
    moveForward = false;
    let shadowPlaceholder = shadow.getShadowPlaceholder();
    stopObserver(shadowPlaceholder);
    positioning.moveBack();
    shadowPlaceholder.style.height = '0px';
    isShadowing = false;
    debug('shadow: inscreen, finish shadow, shadowed ad moved back to original position');
};

window.addEventListener('message', (evt) => {
    if (evt.data.type !== undefined && (evt.data.type.indexOf('wallpaper') !== -1 || evt.data.type.indexOf('hestesko') !== -1)) {
        doShadowing = false;
        debug(`shadow: shouldn't shadow ${evt.data.type}`);
        if (isShadowing) {
            const shadowPlaceholder = shadow.getShadowPlaceholder();
            if (shadowPlaceholder !== null) {
                exitShadowing();
            }
        }
    }
});

const _export_startShadow_ = (id) => {
    if (id === shadowPlaceholderId || id === adId) {
        if (!doShadowing) {
            debug('shadow: shouldn\'t shadow elements on page');
            return;
        }

        if (adImpressionViewable) {
            debug(`shadow: ${adId} is already inscreen, aborting shadowing`);
            return;
        }

        const shadowPlaceholder = shadow.setUpShadowPlaceholderElement();
        if (shadowPlaceholder !== null) {
            startObserver(shadowPlaceholder);
            isShadowing = true;
        }
    }
};

const _export_stopShadow_ = (position) => {
    if (position === adId) {
        debug(`shadow: shadowed ad ${adId} got inscreen`);
        adImpressionViewable = true;
        isShadowing = false;
    }
};

const _export_styleBazaarAd_ = function (id) {};

// @ts-nocheck

const styleElement = function (element, styles) {
    Object.assign(element.style, styles);
};

const _export_placeOrRemove_ = function () {
    const skys = document.querySelectorAll("bazaar-ad[position='skyskraper'][class*='am-bazaar-ad lp_skyskraper']");
    if (skys === null || skys.length < 1) {
        return;
    }
    const isfrontpage = skys[0].parentElement.hasAttribute('data-isfrontpage') && skys[0].parentElement.getAttribute('data-isfrontpage') === 'true';
    if (!isfrontpage) {
        debug('On articlepage, adjusting skyskraper height');
        const stickyContainerArea = skys[0].parentElement.parentElement;
        styleElement(stickyContainerArea, { top: '0', bottom: '0' });
    }
    skys.forEach((sky) => sky.enable());
};

const _export_moveToTop_ = function () {
    const skyContainer = document.getElementsByClassName('skyscraper-ads-container')[0];
    const skyContainerLeft = document.getElementsByClassName('skyscraper-ads-container-left')[0];

    if (skyContainer) {
        skyContainer.style.top = 0;
    }

    if (skyContainerLeft) {
        skyContainerLeft.style.top = 0;
    }
};

function displayTakeover(event) {
    const id = event.slot.getSlotElementId();
    const element = document.getElementById(id);
    const parent = element.parentNode;
    parent.classList.add('takeover-loaded');
    const button = document.createElement('div');
    button.innerHTML = 'Lukk annonsen';
    button.classList.add('takeover-close');
    button.addEventListener('click', () => parent.parentNode.removeChild(parent));
    element.appendChild(button);
}

function styleDoubleFullscreen(element) {
    element.classList.add('parallax');
    Object.assign(element.style, {
        zIndex: 1,
        position: 'absolute',
        top: 0,
        left: 'calc(-50vw + 50%)',
        visibility: 'visible',
        width: '100vw',
        height: '200vh',
        'margin-left': '0px',
        'margin-right': '0px',
    });
}

function hide(layers) {
    layers.map(layer => layer.classList.add('hidden'));
}

function display(layers) {
    layers.map(layer => layer.classList.remove('hidden'));
}

function disableParallax(element) {
    element.classList.remove('parallax');
    Object.assign(element.style, {
        visibility: 'hidden',
    });
}

function styleIframe(iframe, extra = {}) {
    Object.assign(iframe.style, {
        width: '100%',
        height: '100%',
        bottom: 0,
        left: 0,
    }, extra);
}

function styleIframeWrapper(iframe, extra = {}) {
    Object.assign(iframe.parentElement.style, {
        position: 'absolute',
        clip: 'rect(auto, auto, auto, auto)',
        clipPath: 'polygon(0px 0px, 100% 0px, 100% 100%, 0px 100%)',
        left: 0,
        top: 0,
    }, extra);
}

function unsetRelativeParent(bazaarAd) {
    Object.assign(bazaarAd.parentElement.parentElement.style, {
        position: 'unset',
    });
}

const doubleFullscreenCallback = (entries) => {
    entries.forEach(entry => {
        const bazaarAd = entry.target.children[3];
        const layers = Array.prototype.slice.call(entry.target.children);

        if (entry.intersectionRatio > 0) {
            styleDoubleFullscreen(bazaarAd);
            display(layers);
        } else {
            disableParallax(bazaarAd);
            hide(layers);
        }
    });
};

const doubleFullscreenObserver = new IntersectionObserver(doubleFullscreenCallback);

function hideSkyskraper(entry, sky) {
    if (entry.intersectionRatio > 0) {
        // fullscreen is Intersecting
        sky.style.cssText = 'transition:opacity .5s;opacity:0;';
    } else {
        sky.style.cssText = 'transition:opacity .5s;opacity:1;';
    }
}

const fullscreenCallback = (entries) => {
    entries.forEach(entry => {
        const skyLeft = document.querySelector('.article-skyscraper-left');
        if (skyLeft) {
            hideSkyskraper(entry, skyLeft);
        }
        const skyContainers = document.querySelectorAll('.top-sky-container');
        if (skyContainers) {
            skyContainers.forEach(sky => {
                hideSkyskraper(entry, sky);
            });
        }
        const chatbox = document.querySelector(`bazaar-ad[data-id="chatbox-1"]`);
        if (chatbox) {
            if (entry.intersectionRatio > 0) {
                debug('Hide chatbox when displaying parallax', chatbox);
                chatbox.style.display = 'none';
            } else {
                chatbox.style.display = '';
            }
        }
    });
};

const fullscreenObserver = new IntersectionObserver(fullscreenCallback);

function addDoubleFullscreenLayers(bazaarElement, stickyLayerSource) {

    const topLayer = document.createElement('div');
    topLayer.id = 'bazaar-parallaxtop-x2';
    topLayer.classList.add('bazaar-parallaxtop-x2');

    const label = document.createElement('div');
    label.id = 'bazaar-parallax-label-x2';
    label.classList.add('bazaar-parallax-label-x2');

    const bottomLayer = document.createElement('div');
    bottomLayer.id = 'bazaar-parallaxbottom';
    bottomLayer.classList.add('bazaar-parallaxbottom-x2');

    bazaarElement.insertAdjacentElement('beforebegin', topLayer);
    topLayer.insertAdjacentElement('afterend', label);
    bazaarElement.insertAdjacentElement('afterend', bottomLayer);

    if(stickyLayerSource) {
        bazaarElement.insertAdjacentHTML(
            'beforebegin',
            `<div class="bazaar-parallax-x2-sticky-container"><iframe src='${stickyLayerSource}' class="bazaar-parallax-x2-sticky-layer" scrolling="no" allowtransparency="true" frameborder="0"></iframe></div>`
        );
    }

}

function setupDoubleFullscreen(iframe, stickyLayerSource) {
    debug('Creating double fullscreen', iframe, stickyLayerSource);
    let bazaarElement = iframe.closest('bazaar-ad');
    if (!bazaarElement) {
        return;
    }

    bazaarElement.removeLabel();
    addDoubleFullscreenLayers(bazaarElement, stickyLayerSource);
    styleDoubleFullscreen(bazaarElement);
    styleIframe(iframe);
    unsetRelativeParent(bazaarElement);
    bazaarElement.classList.remove('am-bazaar-ad--label');

    doubleFullscreenObserver.observe(bazaarElement.parentElement);
    fullscreenObserver.observe(bazaarElement);
}

function styleParallax(element, extra = {}) {
    element.classList.add('parallax');
    Object.assign(element.style, {
        zIndex: 1,
        position: 'fixed',
        top: 0,
        left: 0,
        visibility: 'visible',
        width: '100vw',
        height: '100vh',
        'margin-left': '0px',
        'margin-right': '0px',
    }, extra);
}

function setupParallax(iframe) {
    let bazaarElement = iframe.closest('bazaar-ad');
    if (!bazaarElement) {
        return;
    }

    bazaarElement.removeLabel();
    if (_export_isArticle_) {
        bazaarElement.firstElementChild.classList.add('bazaar-parallax-article-label');
    } else {
        if (window.location.href.indexOf('www.nettavisen.no') > -1) {
            bazaarElement.firstElementChild.classList.add('bazaar-parallax-nettavisen-label');
        } else {
            bazaarElement.firstElementChild.classList.add('bazaar-parallax-label');
        }
    }

    debug('parallax: bazaar-ad to create parallax for', bazaarElement);

    styleParallax(bazaarElement, {
        left: 'calc(-50vw + 50%)',
        position: 'relative',
    });
    styleIframe(iframe, {
        position: 'fixed',
        backgroundColor: 'var(--page-color)'
    });
    styleIframeWrapper(iframe);
    unsetRelativeParent(bazaarElement);

    fullscreenObserver.observe(bazaarElement);

    // div with ad meta get styled with 100vh with !important, need to hide it make click work
    if (bazaarElement.childElementCount > 1) {
        bazaarElement.lastChild.style.display = 'none';
    }
}

function renderParallax(iframe, type, foregroundUrl) {
    if (window.bazaartag.isTakeoverDisplayed()) {
        let bazaarElement = iframe.closest('bazaar-ad');
        if (!bazaarElement) {
            return;
        }
        debug('Takeover is displayed, do not display parallax, hide adunit', bazaarElement);
        bazaarElement.style.display = 'none';
        return;
    }
    if (type && type === 'bazaar:parallax:x2') {
        debug('parallax: Setting up double parallax');
        setupDoubleFullscreen(iframe, foregroundUrl);
    } else {
        debug('parallax: Setting up parallax');
        setupParallax(iframe);
    }
}

const isRefreshDisabled = () => window.location.href.indexOf('refresh=false') !== -1;

const isDeathPages = () => decodeURIComponent(window.location.href).indexOf('/vis/dødsannonser') > -1 ||
                           decodeURIComponent(window.location.href).indexOf('/vis/dodsannonser') > -1;

let refreshTimeouts = [];

/**
 *  Get the position by parsing the ad unit path in the slot.
 *  NB! Requires the path structure not to change.
 */
const getPositionFromSlot = (slot) => slot.getAdUnitPath().split('/')[3];

const moveSkyskraperPosition = (event) => {
    const isRegularToppbanner = event.size[0] !== 1000;
    if (isRegularToppbanner) {
        debug('Regular toppbanner detected, moving skyskraper to the top');
        _export_moveToTop_();
    }
};

const impressionViewable = () => {
    window.bazaartag.addEventListener('impressionViewable', (event) => {
        debug(`event: impressionViewable ${event.slot.getSlotElementId()}`, event);
        const bazaarTagId = event.slot.getSlotElementId().replace('ad-', '');
        debug(`Impression viewable ${bazaarTagId} @${elapsed()}ms`);
        _export_stopShadow_(bazaarTagId);

        if (!event.isEmpty && window.location.href.indexOf('showads=true') !== -1) {
            window.dispatchEvent(new CustomEvent('visualAds-impressionViewable', {
                detail: {
                    id: bazaarTagId,
                    info: event.slot.getResponseInformation(),
                },
            }));
        }
    });
};

const slotOnLoad = () => {
    window.bazaartag.addEventListener('slotOnload', (event) => {
        debug(`event: slotOnload ${event.slot.getSlotElementId()}`, event);
        const bazaarTagId = event.slot.getSlotElementId().replace('ad-', '');
        debug(`Impression download ${bazaarTagId} @${elapsed()}ms`);
        _export_styleBazaarAd_(event.slot.getSlotElementId());

        let element = document.getElementById(bazaarTagId);
        if (element) {
            element.style.minHeight = '0px';
        }
        if (!event.isEmpty && window.location.href.indexOf('showads=true') !== -1) {
            window.dispatchEvent(new CustomEvent('visualAds-slotOnload', {
                detail: {
                    id: bazaarTagId,
                    info: event.slot.getResponseInformation(),
                },
            }));
        }
    });
};

const createLogMeta = (bazaarAdTag, itemprop, content) => {
    const meta = document.createElement('meta');
    meta.setAttribute('itemprop', itemprop);
    meta.setAttribute('content', content);
    insertAfter(meta, bazaarAdTag.firstChild);
};

function insertAfter(newNode, referenceNode) {
    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}

function isRTBParallax(slotPosition, adIndex, event) {
    return slotPosition === 'midtbanner' && (parseInt(adIndex) === 2 || parseInt(adIndex) === 3)
        && event.size && event.size[0] === 1920 && event.size[1] === 1080;
}

const slotRenderEnded = (frontpage) => {
    window.bazaartag.addEventListener('slotRenderEnded', (event) => {
        debug(`event: slotRenderEnded ${event.slot.getSlotElementId()}`, event);
        let displayEvent = `display:${event.slot.getSlotElementId()}`;
        debug('dispatching custom display event', displayEvent);
        document.dispatchEvent(new CustomEvent(displayEvent, {}));
        const slotPosition = getPositionFromSlot(event.slot);
        const bazaarTagId = event.slot.getSlotElementId().replace('ad-', '');
        const adIndex = bazaarTagId.replace(`${slotPosition}-`, '');

        debug(`Rendered ${bazaarTagId} ${event.size} Index: ${adIndex} ` +
            `(campaignId:${event.campaignId}, creativeId:${event.creativeId}, ` +
            `lineItemId:${event.lineItemId}, isEmpty:${event.isEmpty}) ` +
            `advertiserId:${event.advertiserId} size: ${event.size}` +
            `@${elapsed()}ms - Frontpage: ${frontpage}`);

        const bazaarAdTag = document.querySelector(`bazaar-ad[data-id="${bazaarTagId}"]`);

        if (bazaarAdTag && !event.isEmpty) {
            bazaarAdTag.setAttribute('itemscope', '');
            bazaarAdTag.setAttribute('itemtype', 'http://schema.org/WPAdBlock');
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-element#adpType', 'ad');
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-ad#advertiser', event.advertiserId);
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-ad#creative', event.creativeId);
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-ad#lineItem', event.lineItemId);
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-ad#order', event.campaignId);
            createLogMeta(bazaarAdTag, 'name', slotPosition);
            createLogMeta(bazaarAdTag, 'position', adIndex);
            createLogMeta(bazaarAdTag, 'https://www.adplogger.no/json-schema/meta-ad#unit', 'unknown');
        }

        if (frontpage && isRTBParallax(slotPosition, adIndex, event)) {
            renderParallax(bazaarAdTag.getElementsByTagName('iframe')[0]);
        } else if (!frontpage && isRTBParallax(slotPosition, adIndex, event)) {
            debug('parallax: Tried to render parallax on invalid placement, hiding and aborting further rendering');
            bazaarAdTag.style.display = 'none';
            return;
        }

        if (slotPosition === 'skyskraper') {
            let skyskr = document.querySelector(`div[data-id=${event.slot.getSlotElementId()}]`);
            skyskr.setAttribute('creative-id', event.creativeId);
        }

        if (bazaarTagId.indexOf('takeover') > -1 && !event.isEmpty) {
            displayTakeover(event);
            window.bazaartag.setTakeoverDisplayed();
            const chatbox = document.querySelector(`bazaar-ad[data-id="chatbox-1"]`);
            if (chatbox) {
                debug('Hide chatbox when displaying takeover', chatbox);
                chatbox.style.display = 'none';
            }
        }
        if (event.isEmpty) {
            if (bazaarAdTag) {
                debug(`element: ${bazaarTagId} is empty, setting display none`);
                bazaarAdTag.style.display = 'none';
            }
            debug(`Rendered ${bazaarTagId} empty, aborting further render logic.`);
            return;
        }

        if (!isDeathPages()) {
            _export_placeOrRemove_();
        }

        if (slotPosition === 'toppbanner' || slotPosition === 'toppbannerdods') {
            let isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

            if (!isFirefox) {
                moveSkyskraperPosition(event);
            } else {
                debug('Browser is Firefox, skip moving skyskraper up');
            }
        }
        if (slotPosition === 'skyskraper') {
            const viewportWidthDesktop = 1375;
            window.bazaartag.setTargeting('viewportWidthDesktop', window.innerWidth > viewportWidthDesktop ? 'true' : 'false');

            const sky = document.getElementById(bazaarTagId);
            if (!sky) {
                return;
            }
            {
                const iframe = sky.getElementsByTagName('iframe')[0];
                if (!iframe) {
                    return;
                }
                if (iframe.width !== '1') {
                    sky.style.width = `${iframe.width}px`;
                } else {
                    // Skyskraper width from prebid
                    window.pbjs.onEvent('bidWon', (data) => {
                        let skyskraperId = sky.getAttribute('id');
                        if (data.adUnitCode && data.adUnitCode.indexOf(skyskraperId) > -1) {
                            debug(`Setting skyskraper ${skyskraperId} width ${data.width}px from Prebid`);
                            sky.style.width = `${data.width}px`;
                        }
                    });
                }
            }
        }
        if (event.size && event.size[1] <= 600 && slotPosition === 'midtbanner') {
            addAdvertiserLink(bazaarTagId);
        }
    });
};

function addAdvertiserLink(bazaarTagId) {
    const bazaarAd = document.getElementById(bazaarTagId);
    if (bazaarAd) {
        bazaarAd.setAttribute('advertiser-link', 'display');
    }
}

function shouldRefresh(slotElementId) {
    if (isRefreshDisabled()) {
        debug('Refresh: refresh is disabled');
        return false;
    }
    if (_export_isArticle_ && slotElementId.indexOf('skyskraper') === -1) {
        debug('Refresh: do not refresh article ads');
        return;
    }
    if (slotElementId.indexOf('takeover') > -1) {
        debug('Refresh: do not refresh takeover');
        return false;
    } else if (slotElementId.indexOf('toppbanner') > -1) {
        debug('Refresh: do not refresh toppbanner');
        return false;
    }
    return true;
}

function clearRefreshTimeout(slotElementId) {
    if (refreshTimeouts[slotElementId]) {
        let timeoutId = refreshTimeouts[slotElementId];
        window.clearTimeout(timeoutId);
        refreshTimeouts[slotElementId] = undefined;
        debug('Refresh: Removed refresh for', slotElementId, timeoutId);
    }
}

function setRefreshTimeout(slotElementId) {
    if (shouldRefresh(slotElementId) && !refreshTimeouts[slotElementId]) {
        const timeoutId = window.setTimeout(() => {
            if (shouldRefresh(slotElementId)) {
                debug('Refresh: do refresh for', slotElementId);
                window.bazaartag.refresh(slotElementId);
            }
            refreshTimeouts[slotElementId] = undefined;
        }, 30000);
        refreshTimeouts[slotElementId] = timeoutId;
        debug('Refresh: Added refresh for', slotElementId, timeoutId);
    }
}

const slotVisibilityChanged = () => {
    window.bazaartag.addEventListener('slotVisibilityChanged', (event) => {
        let slotElementId = event.slot.getSlotElementId();
        debug(`event: slotVisibilityChanged ${slotElementId}`, event);
        const bazaarTagId = slotElementId.replace('ad-', '');
        if (event.inViewPercentage === 0) {
            debug(`Visibility changed ${bazaarTagId} - ${event.inViewPercentage}% - @${elapsed()}ms`);
        }
        if (event.inViewPercentage >= 50) {
            setRefreshTimeout(slotElementId);
        } else {
            clearRefreshTimeout(slotElementId);
        }
        if (window.location.href.indexOf('showads=true') !== -1) {
            window.dispatchEvent(new CustomEvent('visualAds-slotVisibilityChanged', {
                detail: {
                    id: bazaarTagId,
                    inViewPercentage: event.inViewPercentage,
                    elapsed: elapsed(),
                },
            }));
        }
    });
};

let elements = [];
let observers = {};
let lazyloadData = {};

/**
 *  Creates an interaction observer with a threshold value
 *  Uses the threshold as a key for saving the interaction observer
 *  @param: integer for px used for threshold
 */
const createObserver = (threshold) => {
    debug('create lazyload observer');
    const observer = new IntersectionObserver((entries) => {
        function logEntry(domElement) {
            const position = domElement.getAttribute('position');
            if (position != null) {
                debug(`Lazyload triggered on bazaar-ad position=${position}, with threshold=${threshold}`);
            } else {
                debug(`Lazyload triggered on an unknown dom element with threshold=${threshold}`);
            }
        }

        entries.forEach((entry) => {
            const index = elements.indexOf(entry.target);

            let renderElement = (index !== -1 && (entry.isIntersecting || entry.intersectionRatio > 0));

            if (renderElement) {
                window.requestAnimationFrame(entry.target.render.bind(entry.target));
                logEntry(entry.target);
                observer.unobserve(entry.target);
                elements.splice(index, 1);
            }
        });
    }, {
        rootMargin: threshold,
    });

    observers[threshold] = observer;
    return observer;
};

const handleThreshold = (element, threshold) => {
    const observer = observers[threshold] || createObserver(threshold);
    if (window.performance && window.performance.navigation.type && window.performance.navigation.type === 2) {
        debug('back navigation detected, freezing ads', element);
        setTimeout(() => {
            window.addEventListener('scroll', () => {
                debug('scroll detected, unfreezing ads', element);
                if (elements.indexOf(element) === -1) {
                    if (element.classList.contains('frozen')) {
                        element.classList.remove('frozen');
                    }
                    elements.push(element);
                    observer.observe(element);
                }
            }, { once: true });
        }, 1000);
    } else if (elements.indexOf(element) === -1) {
        debug('no back navigation detected, loading ad');
        elements.push(element);
        observer.observe(element);
    }
};

function getThreshold(position) {
    if (position === undefined) {
        position = '';
    }
    switch (position) {
    case 'toppbanner':
        return lazyloadData.toppbanner;
    case 'midtbanner':
        return lazyloadData.midtbanner;
    case 'netboard':
        return lazyloadData.netboard;
    case 'artikkelboard':
        return lazyloadData.artikkelboard;
    case 'skyskraper':
        return lazyloadData.skyskraper;
    default:
        return 0;
    }
}

/**
 *  Reads the lazyload threshold values from the config
 *  @param: config
 */
const initLazyloadConfig = (config) => {
    if (isMobile()) {
        lazyloadData = {
            toppbanner: config.mobileToppbanner,
            midtbanner: config.mobileMidtbanner,
            netboard: config.mobileNetboard,
        };
    } else {
        lazyloadData = {
            toppbanner: config.desktopToppbanner,
            midtbanner: config.desktopMidtbanner,
            netboard: config.desktopNetboard,
        };
    }
    lazyloadData.artikkelboard = config.desktopArtikkelboard;
    lazyloadData.skyskraper = config.desktopSkyskraper;
    debug('lazyload: threshold values', lazyloadData);
};

let refreshCalled = false;

let config;

function getBrowser(userAgent, keywords) {
    debug(`targeting: ${userAgent}, keywords: ${keywords}`);
    // To separate articles and frontpage viewings
    let viewTypePostfix = keywords !== null && keywords.indexOf('art') > -1 ? ' art' : ' front';
    if (userAgent.toLowerCase().indexOf('firefox') > -1) {
        return `Firefox${viewTypePostfix}`;
    } else if (userAgent.toLowerCase().indexOf('edge') > -1) {
        return `Edge${viewTypePostfix}`;
    } else if (userAgent.toLowerCase().indexOf('chrome') > -1) {
        return `Chrome${viewTypePostfix}`;
    } else if (userAgent.toLowerCase().indexOf('safari') > -1) {
        return `Safari${viewTypePostfix}`;
    } else if (userAgent.toLowerCase().indexOf('crios') > -1) {
        return `Chrome Mobile${viewTypePostfix}`;
    } else if (userAgent.toLowerCase().indexOf('trident') > -1) {
        return `Internet Explorer${viewTypePostfix}`;
    }
    return '';
}

function setPlussAltTargeting(extraData) {
    const delta = extraData.plussalt_price_delta;
    if (delta !== undefined) {
        const price = parseInt(delta, 10);
        if (isNaN(price)) {
            debug('Plussalt price delta is not a number, targeting aborted', delta);
        } else {
            debug('Targeting plussalt price delta', delta);
            window.bazaartag.setTargeting('plussalt_price_delta', `${delta > 0}`);
        }
    }
    if (extraData.plussalt_eligible) {
        window.bazaartag.setTargeting('plussalt_eligible', `${extraData.plussalt_eligible}`);
    }
    if (extraData.plussalt_subscription !== undefined) {
        window.bazaartag.setTargeting('plussalt_sub', `${extraData.plussalt_subscription === 'TRUE'}`);
    }
}

function setCreditCardTargeting(extraData) {
    const expirationDate = new Date(extraData.cc_expiration_date);
    const now = new Date();
    if (now.getFullYear() === expirationDate.getFullYear() && now.getMonth() === expirationDate.getMonth()) {
        window.bazaartag.setTargeting('credit_card', 'expiring');
    } else if (now.getTime() > expirationDate.getTime()) {
        window.bazaartag.setTargeting('credit_card', 'expired');
    }
}

function isUserGroup(extraData, endsWith) {
    for (let i = 0; i < endsWith.length; i += 1) {
        if ((extraData.user_grouping_number - endsWith[i]) % 10 === 0) {
            return true;
        }
    }
    return false;
}

function setUserGroupTargeting(extraData) {
    if (isUserGroup(extraData, [4])) {
        debug(`usergroup: user has usergroup ${extraData.user_grouping_number}, add targeting user_group=10%`);
        window.bazaartag.setTargeting('user_group', '10%');
    } else if (isUserGroup(extraData, [1, 3, 7, 9])) {
        debug(`usergroup: user has usergroup ${extraData.user_grouping_number}, add targeting user_group=40%`);
        window.bazaartag.setTargeting('user_group', '40%');
    } else {
        debug(`usergroup: user has usergroup ${extraData.user_grouping_number}, add targeting user_group=50%`);
        window.bazaartag.setTargeting('user_group', '50%');
    }
}

function setUserDataTargeting(userAccess, browserId, trackingKey, privacyPreferences, extraData) {
    if (userAccess) {
        debug('Targeting aid aktiv');
        window.bazaartag.setTargeting('aid_active', 'aktiv');
    }

    setPlussAltTargeting(extraData);

    debug('setting user group targeting');

    if (extraData.user_grouping_number) {
        setUserGroupTargeting(extraData);
    }

    if (extraData.cc_expiration_date) {
        setCreditCardTargeting(extraData);
    }

    debug('Targeting aid innlogget');
    window.bazaartag.setTargeting('aid', 'innlogget');

    // If this is a shared account we use browserid as ppid with fallback to user_key
    // If the flag for account sharing is undefined we use user_key as ppid
    const ppid = (!extraData.shared_account
        ? trackingKey
        : browserId || trackingKey
    ).replace(/-/g, '');

    if (privacyPreferences && privacyPreferences.personalizedAds) {
        debug('Sending PPID (ukey): ', ppid);
        window.bazaartag.setPublisherProvidedId(ppid);

        debug('Sending a_user_key:', trackingKey);
        window.bazaartag.setTargeting('a_user_key', trackingKey);
    } else {
        window.bazaartag.setRequestNonPersonalizedAds(1);
    }
}

function setNotLoggedInTargeting(browserId) {
    const ppid = browserId ? browserId.replace(/-/g, '') : '';
    debug('Sending PPID (brws): ', ppid);
    window.bazaartag.setPublisherProvidedId(ppid);

    debug('Sending aid: ', 'ikkeinnlogget');
    window.bazaartag.setTargeting('aid', 'ikkeinnlogget');
}

function getSlotKeywords(keywords, index, position) {
    const midtbannerFrontpage = position === 'midtbanner' && keywords.indexOf('forsiden') > -1;

    if (midtbannerFrontpage && index === 1) {
        keywords = keywords.concat(['cm']);
    }
    if (midtbannerFrontpage && index === 4) {
        keywords = keywords.concat(['cm2']);
    }
    if (keywords.indexOf('forsiden') > -1) {
        return keywords.concat([`forsiden_${index}`]);
    } else if (keywords.indexOf('art') > -1) {
        return keywords.concat([`art_${index}`]);
    } else if (keywords.indexOf('section') > -1) {
        return keywords.concat([`section_${index}`]);
    }

    return keywords;
}

function createSlot(publication, ad) {
    const url = config.slotUrl
        .replace('{publication}', publication)
        .replace('{position}', ad.position);

    if (ad.position !== 'instream' && ad.position !== 'shadow') {
        let slot = createSlot$1({
            url,
            publication,
            id: ad.id,
            slotId: ad.slotId,
            position: ad.position,
            sizeMapping: ad.sizeMapping,
        });
        let slotTargeting = {
            keywords: getSlotKeywords(
                config.keywords,
                ad.index,
                ad.position,
            ),
            positionIndex: ad.index,
            position: ad.position,
            threshold: ad.threshold,
            publication,
        };
        window.bazaartag.setSlotTargeting(slot, slotTargeting);

        debug(`Created slot with elementId: ${ad.slotId}`, slot);
    } else {
        debug(`Did not create slot for ${ad.position}`);
    }
}

/**
 *  Must be called prior to load as it prepares the Google Publisher Tag services for the publication.
 */
function init(data, preparation) {
    debug('Running init');

    config = data;
    const publication = config.publication;

    initLazyloadConfig(config);

    const userAccess = getUserAccess(readCookie('daxsub', {})) || false;

    const getUserData = new UserDataRequest()
        .withAttributes([
            'trackingKey',
            'privacyPreferences',
            'extraData',
        ])
        .fetch(isDebugEnabled() ? { timeout: 1000 } : undefined)
        .catch((e) => {
            if (e instanceof FetchTimeoutError && isDebugEnabled()) {
                // if @amedia/user timeouts and debug is enabled: console error & resolve
                // eslint-disable-next-line no-console
                console.error(e);
            } else {
                throw e;
            }
        });

    return Promise.all([getUserData, getBrowserId(), preparation()])
        .then(([userData, browserId, ads]) => {
            try {
                let segments = [];

                // debug
                debug('About to set audience pixels if applicable');
                debug('userData', userData);
                debug('browserId:', browserId);

                let prebidTargeting = {
                    keywords: config.keywords,
                };

                // register segments
                if (userData) {
                    const { attributes: { extraData } } = userData;
                    if (Object.keys(extraData).length !== 0 && extraData.ad_segments) {
                        segments = extraData.ad_segments.split(',');
                        // createAudiencePixels(config.audiencePixelUrl, segments);
                    }
                    prebidTargeting.visitor = {
                        age: [`${extraData.age}`],
                    };
                }

                initPrebid(ads, prebidTargeting);

                window.bazaartag.cmd.push(() => {
                    debug('Completed initial slot creation of ads', ads.map((ad) => ad.id));

                    impressionViewable();
                    slotOnLoad();
                    slotRenderEnded(config && config.keywords && config.keywords.indexOf('forsiden') > -1);
                    slotVisibilityChanged();

                    window.bazaartag.pauseAdServer();

                    window.bazaartag.setTargeting('user_segments', segments);

                    window.bazaartag.setTargeting('user_segments', segments);
                    window.bazaartag.setTargeting('publication', publication);
                    window.bazaartag.setTargeting('keyword', config.keywords);
                    if (config.categories.length > 0) {
                        window.bazaartag.setTargeting('categories', config.categories);
                    }
                    window.bazaartag.setTargeting('fritekst', config.keywords);
                    window.bazaartag.setTargeting('bazaar', _export_isExtern_);
                    let userAgent = getBrowser(navigator.userAgent, config.keywords);
                    debug(`userAgent=${userAgent}`);
                    window.bazaartag.setTargeting('userAgent', userAgent);

                    const uuid = userUUID();
                    if (uuid) {
                        window.bazaartag.setTargeting('pageview_id', uuid);
                    }

                    if (userData && userData.attributes.trackingKey) {
                        const {
                            attributes: {
                                trackingKey,
                                privacyPreferences,
                                extraData,
                            },
                        } = userData;

                        setUserDataTargeting(userAccess, browserId, trackingKey, privacyPreferences, extraData);
                    } else {
                        setNotLoggedInTargeting(browserId);
                    }

                    debug('Sending a_brws_id:', browserId);
                    window.bazaartag.setTargeting('a_brws_id', browserId);

                    window.bazaartag.enableServices();
                });
            } catch (e) {
                console.error(e);
            }

            return true;
        }).catch(e => console.error(e));
}

/**
*  Loads a slot through Google Publisher Tag.
*/
function load({ position, id, index, slotId }) {
    debug('Running load');
    try {
        if (position === 'shadow') {
            return {
                id,
                position,
                slotId,
                display: () => _export_startShadow_(id, isMobile()),
            };
        }

        const sizeMapping = mapping(position);
        if (!sizeMapping) {
            console.error(`Error getting size-mapping slot for ${position} id=${id} slotId=${slotId}`);
            return false;
        }

        const url = config.slotUrl
            .replace('{publication}', config.publication)
            .replace('{position}', position);

        const prebidConfig = {
            url,
            keywords: config.keywords,
        };

        let prebidAdUnit = createAdunit({ sizeMapping, slotId, position, conf: config, prebidConfig });
        let threshold = getThreshold(position);
        let ad = {
            id,
            threshold,
            slotId,
            prebidAdUnit,
            position,
            sizeMapping,
            index,
            display: (element) => {
                if (slotId === 'ad-instream-1') {
                    debug('Do not call display for placeholder instream');
                    return;
                }
                window.bazaartag.cmd.push(() => {
                    callDisplayWhenPrebidDone(() => {
                        debug(`Calling display for ${slotId}`);
                        window.bazaartag.display(slotId);
                    }, () => {
                        if (!refreshCalled) {
                            debug('Calling loadAds after display');
                            window.bazaartag.loadAds();
                            refreshCalled = true;
                        }
                    }, id);
                });
                _export_startShadow_(id);
                _export_setStylingIfNoFetch_(id);
                init$1();
            },
        };
        window.bazaartag.cmd.push(() => {
            createSlot(config.publication, ad);
        });
        return ad;
    } catch (e) {
        console.error(`Error loading position ${position}, id ${id} slotId ${slotId}`, e);
        return false;
    }
}

// @ts-nocheck

const store = {};

let resolve;

const disableInstreamPrebid = window.location.href.indexOf('instreamPrebid=false') !== -1;

const storeReady = new Promise((_resolve) => {
    resolve = _resolve;
});

/**
 *  Generates a unique id and index with a locking mechanism since it is based on a shared variable in the store.
 */
const generateIdentifier = (position) => new Promise((_resolve) => {
    store.positions[position] = store.positions[position] || {};
    const index = store.positions[position].nextIndex || 1;
    store.positions[position].nextIndex = index + 1;
    const id = `${position}-${index}`;
    const slotId = `ad-${id}`;
    _resolve({ position, id, index, slotId });
});


/**
 *  Loads an ad by generating a unique id for it, fetching it using the loader and returning the ad.
 */
const loadAd = (position) => generateIdentifier(position).then(load);

/**
 * Loads ads and puts them into the store position prepared list.
 */
const prepareAds = (positions) => {
    if (!disableInstreamPrebid && ((document.querySelector('amedia-video') || document.querySelector('amedia-smartembed-video')) || window.location.href.indexOf('nettavisen.no') !== -1)) {
        debug('Detected amedia-video, appending instream position');
        positions.push('instream');
    }

    return Promise.all(positions.map(position => {
        store.positions[position] = store.positions[position] || {};
        store.positions[position].prepared = store.positions[position].prepared || [];

        return loadAd(position)
            .then((ad) => {
                store.positions[position].prepared.push(ad);
                return ad;
            });
    }));
};

/**
 *  Prepares the store by reading the config and loading the ads.
 */

config$2().then((_config) => {
    store.config = _config;
    store.positions = {};

    init(_config, () => prepareAds(store.config.positions)).then(() => {
        function isDFPLoaded() {
            if (!window.bazaartag.isReady()) {
                setTimeout(isDFPLoaded, 5);
            } else {
                resolve(store);
            }
        }
        isDFPLoaded();
    });
});

/**
 *  Extracts a prepared ad from the stores prepared list or else returns undefined.
 */
const getPreparedAd = (position) => (store.positions[position] && store.positions[position].prepared
    ? store.positions[position].prepared.shift()
    : undefined);

/**
 *  Returns an ad by either getting an ad ready for display or loading a new ad.
 */
const getAd = (position) => storeReady
    .then(() => getPreparedAd(position))
    .then((ad) => (ad || loadAd(position)));

const getAllAds = () => storeReady.then(() => store);

function getDynamicPosition() {
    return storeReady.then(() => {
        if (!store.config.dynamicPositionOrder || !store.config.dynamicPositionOrder.length) {
            return 'missing';
        }
        return store.config.dynamicPositionOrder.shift();
    });
}

const configWallpaper = {
    width: 1920,
    height: 1020,
    linkHeight: 1000,
    stickyHeight: 1985,
    left: 'calc(50% - (1000px / 2) - 460px)',
    adHeight: '',
};

const configHorseshoe = {
    width: 1360,
    height: 720,
    linkHeight: 700,
    stickyHeight: 1985,
    left: 'calc(50% - (1000px / 2) - 180px)',
    adHeight: '',
};

const dom = {
    createLink(clickUrl, config) {
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', `${clickUrl}`);
        linkElement.setAttribute('target', '_blank');
        Object.assign(linkElement.style, {
            display: 'block',
            height: `${config.linkHeight}px`,
            left: `${config.left}`,
            position: 'absolute',
            top: '0px',
            width: `${config.width}px`,
        });
        return linkElement;
    },
    styleIframe(element, config) {
        Object.assign(element.style, {
            height: `${config.height}px`,
            left: `${config.left}`,
            width: `${config.width}px`,
        });
    },
    styleAbsoluteContainer(element, config) {
        Object.assign(element.style, {
            top: '0px',
            position: 'absolute',
            width: `${config.width}px`,
        });
        element.style.setProperty('height', `${config.stickyHeight}px`, 'important');
    },
    styleStickyContainer(element, config) {
        Object.assign(element.style, {
            left: `${config.left}`,
            display: 'flex',
            alignItems: 'flex-start',
            position: 'sticky',
            top: '30px',
        });
        element.style.setProperty('height', `${config.height}px`, 'important');
    },
    styleBazaarTagContainer(element, config) {
        Object.assign(element.style, {
            left: `${config.left}`,
            position: 'relative',
            display: 'block',
            height: `${config.adHeight}px`,
            width: `${config.width}px`,
        });
    },
};

const templates = (() => {
    let _absoluteContainer;
    let _stickyContainer;
    let _adContainer;
    let _iframe;

    const initVariables = (bazaarTag) => {
        _adContainer = document.getElementById('ad-toppbanner-1');
        _iframe = _adContainer.querySelector('iframe');
        _stickyContainer = bazaarTag.getElementsByClassName('stickyContainer')[0];
        _absoluteContainer = bazaarTag.getElementsByClassName('absoluteContainer')[0];
    };

    const styleContainers = (bazaarTag, config) => {
        dom.styleIframe(_iframe, config);
        dom.styleStickyContainer(_stickyContainer, config);
        dom.styleAbsoluteContainer(_absoluteContainer, config);
        dom.styleBazaarTagContainer(bazaarTag, config);
        bazaarTag.classList.remove('am-bazaar-ad--labeled');
        _stickyContainer.classList.add('am-bazaar-ad--labeled');
    };

    const setAdHeight = (config) => {
        config.adHeight = Number(_iframe.height.replace('px', '')) + (window.location.href.indexOf('www.nettavisen.no') > -1 ? 0 : 20);
    };

    const createLink = (url, config) => {
        if (_adContainer) {
            _adContainer.appendChild(dom.createLink(url, config));
        }
    };

    const createTemplate = (bazaarTag, config) => {
        initVariables(bazaarTag);
        setAdHeight(config);
        styleContainers(bazaarTag, config);
    };

    return {
        wallpaper: {
            createScriptScript: (data, bazaarTag) => {
                createTemplate(bazaarTag, configWallpaper);
            },
            createScriptImg: (data, bazaarTag) => {
                createTemplate(bazaarTag, configWallpaper);
                createLink(data.clickUrl, configWallpaper);
                const advertiserIsAdform = data.advertiser !== undefined && data.advertiser === 'adform';
                if (advertiserIsAdform) {
                    _adContainer.style.paddingLeft = '0px';
                } else {
                    _adContainer.style.paddingLeft = '460px';
                }
                if (data.background) {
                    _stickyContainer.style.background = `url(${data.background.img}) 0px 0px no-repeat`;
                }
            },
            createImgImg: (data, bazaarTag) => {
                createTemplate(bazaarTag, configWallpaper);
                createLink(data.clickUrl, configWallpaper);
                if (data.top) {
                    _adContainer.style.background = `url(${data.top.img}) 460px 0px no-repeat`;
                }
                if (data.background) {
                    _stickyContainer.style.background = `url(${data.background.img}) 0px 0px no-repeat`;
                }
            },
        },
        horseshoe: {
            createScriptScript: (data, bazaarTag) => {
                createTemplate(bazaarTag, configHorseshoe);
            },
            createImgImg: (data, bazaarTag) => {
                createTemplate(bazaarTag, configHorseshoe);
                createLink(data.clickUrl, configHorseshoe);
                if (data.top && data.left && data.left) {
                    // LEFT AD
                    const leftImg = document.createElement('div');
                    Object.assign(leftImg.style, {
                        order: 1,
                        background: `url(${data.left.img}) 0px 0px no-repeat`,
                    });
                    leftImg.style.setProperty('width', `${data.left.width}px`, 'important');
                    leftImg.style.setProperty('height', `${data.left.height}px`, 'important');

                    // RIGHT AD
                    const rightImg = document.createElement('div');
                    Object.assign(rightImg.style, {
                        order: 3,
                        background: `url(${data.right.img}) 0px 0px no-repeat`,
                    });
                    rightImg.style.setProperty('width', `${data.right.width}px`, 'important');
                    rightImg.style.setProperty('height', `${data.right.height}px`, 'important');

                    // TOPPBANNER STYLING
                    _adContainer.style.background = `url(${data.top.img}) 0px 0px no-repeat`;
                    _adContainer.style.order = 2;
                    _adContainer.style.setProperty('width', `${data.top.width}px`, 'important');


                    // ADD CHILDREN TO FLEX CONTAINER
                    _stickyContainer.appendChild(leftImg);
                    _stickyContainer.appendChild(rightImg);

                    // PARENT STYLING
                    const totalWidth = data.left.width + data.top.width + data.right.width;
                    _absoluteContainer.style.width = `${totalWidth}px`;
                }
            },
        },
    };
})();

const _export_wallpaper_ = templates.wallpaper;
const _export_horseshoe_ = templates.horseshoe;

const createWallpaper = (data, template) => {
    const topbanner = document.querySelector('bazaar-ad[position="toppbanner"]');
    const frontpage = document.querySelector('amedia-frontpage');
    if (topbanner === null || !topbanner.querySelector('iframe')) {
        return;
    }
    if (window.bazaartag.isTakeoverDisplayed() && !_export_isNettavisen_) {
        debug('Takeover is displayed, do not display wallpaper, hide adunit', topbanner);
        topbanner.style.display = 'none';
        return;
    }
    if (frontpage) {frontpage.classList.add('wallpaper');}
    topbanner.classList.add('wallpaper');
    template(data, topbanner);

    window.bazaartag.setTopbannerSpecialFormatDisplayed();
};

window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:wallpaper_img_img') {
        debug('Wallpaper with two images ready: ', evt.data);
        createWallpaper(evt.data, _export_wallpaper_.createImgImg);
    }

    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:wallpaper_script_img') {
        debug('Wallpaper with script and image ready: ', evt.data);
        createWallpaper(evt.data, _export_wallpaper_.createScriptImg);
    }

    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:wallpaper_script_script') {
        debug('Wallpaper with two scripts ready: ', evt.data);
        createWallpaper(evt.data, _export_wallpaper_.createScriptScript);
    }
});

window.addEventListener('externalSitesWallpaper', (evt) => {
    if (evt.detail !== undefined && evt.detail.type !== undefined && evt.detail.type === 'bazaar:wallpaper_img_img') {
        debug('External sites testing wallpaper with two images ready: ', evt.detail);
        createWallpaper(evt.detail, _export_wallpaper_.createImgImg);
    }

    if (evt.detail !== undefined && evt.detail.type !== undefined && evt.detail.type === 'bazaar:wallpaper_script_img') {
        debug('External sites testing wallpaper with script and images ready: ', evt.detail);
        createWallpaper(evt.detail, _export_wallpaper_.createScriptImg);
    }

    if (evt.detail !== undefined && evt.detail.type !== undefined && evt.detail.type === 'bazaar:wallpaper_script_script') {
        debug('External sites testing wallpaper with two script ready: ', evt.detail);
        createWallpaper(evt.detail, _export_wallpaper_.createScriptScript);
    }
});

const createTemplate = (data, template) => {
    const topbanner = document.querySelector('bazaar-ad[position="toppbanner"]');
    const frontpage = document.querySelector('amedia-frontpage');
    if (topbanner === null || !topbanner.querySelector('iframe')) {
        return;
    }
    if (window.bazaartag.isTakeoverDisplayed() && !_export_isNettavisen_) {
        debug('Takeover is displayed, do not display horseshoe, hide adunit', topbanner);
        topbanner.style.display = 'none';
        return;
    }
    if (frontpage) {frontpage.classList.add('horseshoe');}
    topbanner.classList.add('horseshoe');
    template(data, topbanner);
    window.bazaartag.setTopbannerSpecialFormatDisplayed();
};

window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:hestesko_img_img_img') {
        debug('Horseshoe with two images ready: ', evt.data);
        createTemplate(evt.data, _export_horseshoe_.createImgImg);
    }

    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:hestesko_script_script_script') {
        debug('Horseshoe 3xscript ready: ', evt.data);
        createTemplate(evt.data, _export_horseshoe_.createScriptScript);
    }
});

window.addEventListener('externalSitesHorseshoe', (evt) => {
    if (evt.detail !== undefined && evt.detail.type !== undefined && evt.detail.type === 'bazaar:hestesko_img_img_img') {
        debug('External sites testing horseshoe with two images ready: ', evt.detail);
        createTemplate(evt.detail, _export_horseshoe_.createImgImg);
    }
});

window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:mobile_fullwidth') {
        debug('Mobile_fullwidth ready: ', JSON.stringify(evt.data));
        const { elementId } = evt.data;
        const container = document.querySelector(`bazaar-ad[id=${elementId}]`);

        if (!container) {
            return;
        }

        Object.assign(container.style, { width: '100%' });

        const googleChild = container.firstChild;

        if (!googleChild) {
            return;
        }

        Object.assign(googleChild.style, { width: '100%' });

        const safeFrame = container.querySelector('iframe');

        if (!safeFrame) {
            return;
        }

        Object.assign(safeFrame.style, { width: '100%' });
    }
});

// Bazaar listener to handle callbacks from DFP native templates.
window.addEventListener('message', (evt) => {
    function adjustContent (iframe, el, width, height) {
        const adHasSameDimensionsAsNativeTemplate = iframe.getAttribute("width") === width && iframe.getAttribute("height") === height;
        if (adHasSameDimensionsAsNativeTemplate) {
            removeLabel(el);
            alignElement(el);
        }

        function removeLabel(element) {
            element.setAttribute("labeled", "false");
        }

        function alignElement(element) {
            const align = function (textAlign) {
                const container = element.firstChild;
                if (container) {
                    container.style.width = null;
                    container.style.textAlign = textAlign;
                }
            };
            if (element.previousElementSibling !== null) {
                align("right");
            } else if (element.nextElementSibling !== null) {
                align("left");
            }
        }
    }

    function eventFromNativeTemplate () {
        return evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:native_template_ad';
    }

    if (eventFromNativeTemplate()) {
        const position = evt.data.adUnit.split("/")[3];
        const height = evt.data.height;
        const width = evt.data.width;

        debug("native: dfp template sent postmessage to bazaar with data: ", position);

        const adsInThisPosition = document.querySelectorAll(`bazaar-ad[position=${position}]`);
        if (adsInThisPosition) {
            for (const ad of Array.from(adsInThisPosition)) {
                const iframe = ad.querySelector("iframe");
                if (iframe) {
                    adjustContent(iframe, ad, width, height);
                }
            }
        }
    }
});

function getCallingIframe$1(evt) {
    return [].slice.call(document.querySelectorAll('iframe')).filter(iframeElement => iframeElement.contentWindow === evt.source);
}

function eventFromNativeTemplate(evt) {
    return evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:native_video_full_template_ad';
}

function eventFromNativeHeadlineTemplate(evt) {
    return evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:native_with_headline';
}

window.addEventListener('message', (evt) => {
    const iframe = getCallingIframe$1(evt);
    if (!iframe || !iframe[0]) {
        return;
    }

    if (eventFromNativeTemplate(evt) && isMobile()) {
        debug('native: dfp native video full template sent postmessage to bazaar with data: ', evt.data);
        iframe[0].style.height = evt.data.videoHeight;
        debug(`native: calling iframe got style height ${evt.data.videoHeight}`);
    }

    if (eventFromNativeHeadlineTemplate(evt)) {
        debug('native: Removing label, dfp native video full headline sent postmessage with data: ', evt.data);
        const bazaarElement = iframe[0].closest('bazaar-ad');
        bazaarElement.removeLabel();
    }
});

// DFP Template for outstream håndterer outstream sine callbacks da outstream nå ligger i egen iframe.
// Postmessage sendes fra dfp-template til bazaar som håndterer ting videre (i koden nedenfor).
// DFP-template: https://www.google.com/dfp/56257416#delivery/CreateCreativeTemplate/creativeTemplateId=10147976
window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:outstream_adunits') {
        debug("Outstream: dfp template sent postmessage to bazaar with data: ", evt.data);
        const {typeOfOutstreamEvent} = evt.data;

        const bazaarContainer = document.querySelector("bazaar-ad[position='outstreamvideo']");
        if (!bazaarContainer) {
            debug("Outstream: no bazaar-ad[position='outstreamvideo'] element found in DOM");
            return;
        }

        const adcontainer = document.getElementById("smartclipContainer"),
            closeButton = document.getElementById("smartclipClose");

        if (closeButton) {
            closeButton.addEventListener("click", function () {
                hideAd();
            });
        }

        function sendEvent (details) {
            window.dispatchEvent(
                new CustomEvent('seshat-set', {
                    detail: details
                })
            );
        }

        function hideAd() {
            if (bazaarContainer) {
                bazaarContainer.className = "";
            }
            if (closeButton) {
                closeButton.style.display = "none";
            }
            if (adcontainer) {
                adcontainer.style.display = "none";
            }
        }

        function showAd() {
            if (bazaarContainer) {
                bazaarContainer.classList.add("am-bazaar-ad--labeled");
                bazaarContainer.classList.add("am-bazaar-ad--smartclip-label-override");
            }
            if (closeButton) {
                closeButton.style.display = "inline-block";
            }
        }

        //Callback ad starts
        if (typeOfOutstreamEvent === "sc_smartIntxtStart") {
            debug('Outstream: ad started');
            showAd();
            sendEvent({'outstream-adshown': true});
        }

        //Callback no ad
        if (typeOfOutstreamEvent === "sc_smartIntxtNoad") {
            debug('Outstream: ad not found');
            hideAd();
            sendEvent({'outstream-adshown': false});
        }
    }
});

function getCallingIframe(evt) {
    return [].slice.call(document.querySelectorAll('iframe')).filter(iframeElement => iframeElement.contentWindow === evt.source);
}

window.addEventListener('message', (evt) => {
    // IMAGE OR SCRIPT TEMPLATE
    if (evt.data !== undefined && evt.data.type !== undefined && (evt.data.type === 'bazaar:parallax' || evt.data.type === 'bazaar:parallax:x2' || evt.data.type === 'bazaar:parallax-script')) {
        debug(`Got parallax event: ${evt.data.type}`);
        const iframe = getCallingIframe(evt);
        if (!iframe[0]) {
            return;
        }
        let foregroundUrl = evt.data.foreground_url || undefined;
        renderParallax(iframe[0], evt.data.type, foregroundUrl);
    }
});

window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:prebid-native') {
        debug('Prebid native: received data', evt.data);
        const contentDiv = document.querySelector(`div[id=${evt.data.positionId}]`);
        let bazaarElement = contentDiv.closest('bazaar-ad');
        bazaarElement.removeLabel();
        let divToHide = contentDiv.querySelector(`div[id=div_utif_${evt.data.positionId}]`);
        divToHide.style.display = 'none';
    }
});

const templateScript = (adId) => {
    let s = `var w = window; for (i = 0; i < 10; i++) { w = w.parent; if (w.pbjs) { try { w.pbjs.renderAd(document, '${adId}'); break; } catch (e) { continue; } } }`;
    let scriptElement = document.createElement('script');
    scriptElement.innerHTML = s;
    return scriptElement;
};

window.addEventListener('message', (evt) => {
    if (evt.data !== undefined && evt.data.type !== undefined && evt.data.type === 'bazaar:prebid-video') {
        debug('Prebid native: received data', evt.data);
        const contentDiv = document.querySelector(`div[id=${evt.data.positionId}]`);
        let script = templateScript(evt.data.adId);
        let divToHide = contentDiv.querySelector(`div[id=div_utif_${evt.data.positionId}]`);
        divToHide.style.display = 'none';
        contentDiv.appendChild(script);
    }
});

var viseLink = (appendTo, mobile) => {
    if (window.location.href.indexOf( 'nettavisen.no' ) === -1) {
        const link = document.createElement('div');
        link.setAttribute('class', 'advertise-link');
        if (mobile) {
            link.innerHTML =
                `<a href="https://www.vise.no/vis/annonsekjop?adlink=click" class="lp_advertiser_link_logo"><span class="advertise-link-logo">Vise</span> din egen annonse her?</a>`;
        } else {
            link.innerHTML =
                `<a href="https://www.vise.no/vis/annonsekjop?adlink=click" class="lp_advertiser_link_logo"><span class="advertise-link-logo">Vise</span> din egen annonse her? Prøv vår nye selvbetjente løsning!</a>`;
        }
        appendTo.appendChild(link);
    }
};

const cssLabel = 'am-bazaar-ad--labeled';
const cssNoLabel = 'am-bazaar-ad--nolabel';

const minHeightPositions = ['toppbanner', 'midtbanner', 'netboard', 'netboardsmb', 'midtbannersmb', 'cm1', 'cm2'];

class bazaarAdGPT extends HTMLElement {
    render() {
        if (this.isDisabled()) {
            return;
        }

        this.ad.then((ad) => {
            this.removeLoadSpinner();
            if (this.isAdRendered()) {
                debug(`ElementId: ${ad.id} is already rendered, aborting render`);
                return;
            }
            if (ad) {
                debug(`ElementId: ${ad.id} is in viewport, attached elementId to element in DOM`);

                // this is for external sites trying to show skyskraper on narrower viewports
                const viewWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || 0);
                if (ad.id === 'skyskraper-1' && viewWidth < 1375) {
                    debug('Tried to display skyskraper in viewport under 1375px, do not display');
                    return;
                }

                if (this.hasAttribute('labeled') && this.getAttribute('labeled') === 'true') {
                    this.addLabel();
                }
                this.setId(ad);
                ad.display(this);
                this.adRendered = true;
                document.dispatchEvent(new CustomEvent('bazaar:logViewportData', {
                    detail: this,
                }));
            }
        });
    }

    addAdvertiserLink() {
        viseLink(this, isMobile());
    }

    isAdRendered() {
        return this.adRendered;
    }

    getPosition() {
        this.position = this.getAttribute('position');
        if (this.position === 'dynamic') {
            return getDynamicPosition().then(position => {
                this.position = position;
                if (position === 'missing') {
                    this.disable();
                    this.remove();
                }
            });
        }
        return Promise.resolve();
    }

    create() {
        if (this.isCreated) {
            return Promise.resolve();
        }
        this.isCreated = true;

        this.adRendered = false;
        return this.getPosition()
            .then(() => {
                if (window.location.href.indexOf('nettavisen.no') !== -1) {
                    if (window.performance && window.performance.navigation.type && window.performance.navigation.type === 2) {
                        this.classList.add('frozen');
                    } else {
                        this.setMinHeightForElement();
                        if (this.classList.contains('frozen')) {
                            this.classList.remove('frozen');
                        }
                    }
                } else {
                    this.setMinHeightForElement();
                }
                while (this.hasChildNodes()) {
                    this.removeChild(this.firstChild);
                }

                this.createAdContainer();
            });
    }

    connectedCallback() {
        if (this.connected === true) { return; }
        this.connected = true;
        this.create().then(() => this.init());
    }

    remove() {
        debug('Removing bazaar-ad element', this);
        this.parentNode.removeChild(this);
    }

// registerElement fallback
    attachedCallback() {
        if (this.connected === true) { return; }
        this.connected = true;
        this.create().then(() => this.init());
    }

    init() {
        if (!this.isCreated) {
            this.create().then(() => this.init());
            return;
        }
        if (this.isDisabled()) {
            return;
        }

        this.ad = getAd(this.position);
        const element = this;
        let thresholdValue = '0px';
        this.ad.then((ad) => {
            this.setDataId(ad);
            if (ad.threshold) {
                thresholdValue = `${ad.threshold}px`;
            }
            handleThreshold(element, thresholdValue);
        });

        if (window.location.href.indexOf('nettavisen.no') !== -1) {
            if (window.performance && window.performance.navigation.type && window.performance.navigation.type !== 2) {
                this.addLoadSpinner();
            }
        } else {
            this.addLoadSpinner();
        }
    }

    addLoadSpinner() {
        const addSpinnerObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                if (entry.intersectionRatio > 0 && !this.spinnerRemoved) {
                    if (this.position !== 'shadow' && this.position !== 'takeover' && this.position !== 'chatbox') {
                        debug(`Adding load spinner for ${this.position}`);
                        this.bazaarSpinner = document.createElement('div');
                        this.bazaarSpinner.setAttribute('class', 'bazaarSpinnerContainer');
                        this.bazaarSpinner.innerHTML = '<bazaar-amedia-spinner><span><span class="dots"></span></span></bazaar-amedia-spinner>';
                        this.appendChild(this.bazaarSpinner);
                    }
                }
                addSpinnerObserver.disconnect();
            });
        });
        addSpinnerObserver.observe(this);
    }

    removeLoadSpinner() {
        if (this.bazaarSpinner !== undefined) {
            this.removeChild(this.bazaarSpinner);
        }
        this.spinnerRemoved = true;
    }
    /**
     * Defines attributes this element observes. Allows us to hook into
     * attributeChangedCallback for the specified attributes.
     */
    static get observedAttributes() {
        return ['disabled', 'labeled', 'advertiser-link'];
    }

    setMinHeightForElement() {
        if (minHeightPositions.indexOf(this.position) !== -1) {
            this.setMinHeight(this.position);
        }
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        if (attr === 'disabled' && !this.hasAttribute('disabled')) {
            this.init();
        }
        if (attr === 'labeled' && this.hasAttribute('labeled')) {
            if (newValue === 'true' || newValue === true) {
                this.addLabel();
            }
            if (newValue === 'false' || newValue === false) {
                this.removeLabel();
            }
        }
        if (attr === 'advertiser-link' && !oldValue && newValue === 'display') {
            this.addAdvertiserLink();
        }
    }

    /**
     *  Sets id-attribute on both bazaar-tag and on ad-container
     */
    setId(ad) {
        this.adContainer.setAttribute('id', ad.slotId);
        this.setAttribute('id', ad.id);
    }

    setDataId(ad) {
        this.adContainer.setAttribute('data-id', ad.slotId);
        this.setAttribute('data-id', ad.id);
    }

    /**
     *  Removes the 'annonse'-label from the ad
     */
    removeLabel() {
        this.classList.remove(cssLabel);
        this.classList.add(cssNoLabel);
    }

    /**
     *  Adds the 'annonse'-label to the ad
     */
    addLabel() {
        this.classList.add(cssLabel);
        this.classList.remove(cssNoLabel);
    }

    /**
     * Checks if element is disabled
     */
    isDisabled() {
        return this.hasAttribute('disabled');
    }

    /**
     * Disabling element
     */
    disable() {
        if (this && !this.isDisabled()) {
            this.setAttribute('disabled', 'disabled');
        }
    }

    enable() {
        if (this && this.isDisabled()) {
            this.removeAttribute('disabled');
        }
    }

    /**
     *  Sets the default min-height for ad based on the ad-position.
     */
    setMinHeight(position) {
        if (!mapping(position)) {
            return;
        }

        const DESKTOP_BREAKPOINT = 1200;
        const minHeight = window.screen.width > DESKTOP_BREAKPOINT
            ? mapping(position).minHeight.desktop
            : mapping(position).minHeight.mobile;

        this.style.minHeight = `${minHeight}px`;
    }

    sticky() {
        _export_stickToTop_(this);
    }

    createAdContainer() {
        this.adContainer = document.createElement('div');
        if (this.position === 'toppbanner') {
            const parent = this.parentNode;
            const wrapper = document.createElement('div');
            wrapper.classList.add('bazaar-ad-wrapper');
            parent.replaceChild(wrapper, this);
            wrapper.appendChild(this);

            const stickyContainer = document.createElement('div');
            const absoluteContainer = document.createElement('div');
            stickyContainer.classList.add('stickyContainer');
            absoluteContainer.classList.add('absoluteContainer');
            stickyContainer.appendChild(this.adContainer);
            absoluteContainer.appendChild(stickyContainer);
            this.appendChild(absoluteContainer);
        } else {
            this.appendChild(this.adContainer);
        }
    }
}

if (customElements && customElements.define) {
    customElements.define('bazaar-ad', bazaarAdGPT);
} else {
    document.registerElement('bazaar-ad', {
        prototype: bazaarAdGPT.prototype,
    });
}

window.bazaarLoadStart = Date.now();
