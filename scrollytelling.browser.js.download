var scrollytelling_browser = {};

/**
 * A library simplifying use of adplogger
 * @module adploggerlib
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var noop = function noop() {};
var initialized = false;
var loggerWin = void 0;

/**
 * Side effect: Dispatch the event on the window
 *
 * @param {string} event The event name
 * @param {*=} data Data to attach to the event
 * @return {?Error} Error message, or null if successful
 * @private
 */
function sendEvent(adpEventName, data) {
    if (typeof adpEventName !== 'string') {
        return new TypeError('adpEventName must have type "string" (#sendEvent)');
    }

    if (!loggerWin) {
        loggerWin = window;
    }

    loggerWin.postMessage({
        adpEventName: adpEventName,
        data: data
    }, '*');

    return null;
}

/**
 * When adplogger is initialized in another window, e.g. you are an iframe and
 * apdlogger is initialized in your parent, this method can be used to inform
 * the library about which window adplogger resides in.
 *
 * Side effect: loggerWindow will be set as target for postMessage
 *
 * @example
 * // Parent of this iframe has initialized adplogger in its window --> set
 * // parent as loggerWindow
 * var error = adplogger.setLoggerWindow(window.parent);
 * if (error) {
 *   console.error('Argument must be valid window object:', error);
 * else {
 *   // Use as normal -->
 *   adplogger.add({ something: 42 });
 * }
 *
 * @param {Window} loggerWindow=window The window object where adplogger lives
 * @return {?TypeError} Error message if wrong argument type, else null
 */
function setLoggerWindow(loggerWindow) {
    if (typeof loggerWindow.postMessage !== 'function') {
        return new TypeError('loggerWindow must be a valid Window object');
    }

    loggerWin = loggerWindow;
    return null;
}

/**
 * Precondition: adplogger is or will be initialized
 * Side effect: Set 'initialized' variable (such that next call will be cheaper)
 *
 * @example
 * // We want to do something after adplogger has initialized successfully
 * adplogger.onAlive(function (error) {
 *   if (error) {
 *      console.error('Failed to get response from adplogger:', error);
 *      return;
 *   }
 *   // Do your thing -->
 * });
 *
 * @param {Function} next Function to call when adplogger is ready and responding
 */
function onAlive(next) {
    var error = null;

    if (initialized) {
        next(error);
        return;
    }

    window.addEventListener('message', function aliveListener(evt) {
        if (!evt.data || evt.data.adpEventName !== 'seshat-alive') {
            return;
        }
        window.removeEventListener('message', aliveListener);
        initialized = true;
        next(error);
    });
    error = sendEvent('seshat-ping');
}

/**
 * @param {Function} onSuccess Function to call when onAlive returns successfully
 * @param {Function=} onError Function to call when onAlive returns erroneously
 * @private
 */
function onAliveWrapper(onSuccess, onError) {
    onAlive(function (error) {
        if (error) {
            onError(error);
            return;
        }
        onSuccess();
    });
}

/**
 * Precondition: adplogger not previously initialized (anywhere in the webpage)
 * Side effect: The script has been inserted in the HTML, adplogger has initialized
 *
 * @example
 * // Will initialize ADP-logger, and always add metadata to tracking events
 * adplogger.initialize(url, {
 *      metadata: {
 *          page: 'main',
 *          browser: 'chrome',
 *      },
 * }, function (error) {
 *      if (error) {
 *          console.error('something bad happened while initializing:', error);
 *          return;
 *      }
 *      console.log('successfully initialized ADP-logger');
 * });
 *
 * @param {string} url The URL to retrieve adplogger script from
 * @param {Object=} data Any data to pass to adplogger on initialization (see https://github.com/amedia/adplogger for more info)
 * @param {Function=} next Function to call on return
 */
function initialize(url) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if (typeof url !== 'string' || url.length === 0) {
        next(new TypeError('url is required to be a string longer than 0 (#initialize)'));
        return;
    }

    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null) {
        next(new TypeError('If provided, data must be a non-null object (#initialize'));
        return;
    }

    var script = document.createElement('script');
    var refNode = document.getElementsByTagName('script')[0];
    script.type = 'text/javascript';
    script.async = true;
    script.src = url;

    script.onload = function () {
        var error = sendEvent('seshat-initialize', data);
        if (error) {
            next(error);
            return;
        }
        onAlive(next);
    };
    refNode.parentNode.insertBefore(script, refNode);
}

/**
 * Precondition: adplogger is or will be initialized
 * Side effect: Add key-value pairs in 'data' to adplogger, adding duplicates
 *      to an array
 *
 * @example
 * // We want to add tracking data
 * adplogger.add({ theAnswer: 42 }, function (error) {
 *   if (error) {
 *      console.error('Failed to add tracking data:', error);
 *   }
 * });
 *
 * @param {Object.<string, (number|string|boolean)>} data key-value pairs to track
 * @param {Function=} next Function to call on return
 */
function add(data) {
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    if (!initialized) {
        onAliveWrapper(add.bind(null, data, next), next);
        return;
    }

    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
        next(new TypeError('data is required to be a non-null object (#add)'));
        return;
    }

    var error = sendEvent('seshat-add', data);
    next(error);
}

/**
 * Precondition: adplogger is or will be initialized
 * Side effect: Set key-value pairs in 'data' in adplogger, overwriting duplicates
 *
 * @example
 * // We want to add or overwrite previous tracking data
 * adplogger.set({ theAnswer: 43 }, function (error) {
 *   if (error) {
 *      console.error('Failed to set tracking data:', error);
 *   }
 * });
 *
 * @param {Object.<string, (number|string|boolean)>} data key-value pairs to track
 * @param {Function=} next Function to call on return
 */
function set(data) {
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    if (!initialized) {
        onAliveWrapper(set.bind(null, data, next), next);
        return;
    }

    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
        next(new TypeError('data is required to be a non-null object (#set)'));
        return;
    }

    var error = sendEvent('seshat-set', data);
    next(error);
}

/**
 * Precondition: adplogger is or will be initialized
 * Side effect: Add data, and send all tracking data to backend
 *
 * @example
 * // We want to add, set, and immediately send tracking data
 * adplogger.send({
 *   add: {
 *     theAnswer: 42
 *   },
 *   set: {
 *     theQuestion: 'unknown'
 *   }
 * }, function (error) {
 *   if (error) {
 *      console.error('Failed to send tracking data:', error);
 *      return;
 *   }
 *   // We know tracking data has been stored and can safely redirect (or whatever)
 * });
 *
 * @param {Object=} data
 * @param {Object.<string, (number|string|boolean)>=} data.set
 *      The data to set (same usage as [set]{@link #module_adploggerlib.set})
 * @param {Object.<string, (number|string|boolean)>=} data.add
 *      The data to add (same usage as [add]{@link #module_adploggerlib.add})
 * @param {Function=} next Function to call on return
 */
function send() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var next = arguments[1];

    var error = null;

    if (!initialized) {
        onAliveWrapper(send.bind(null, data, next), next);
        return;
    }

    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null) {
        next(new TypeError('If provided, data must be a non-null object (#initialize'));
        return;
    }

    error = Object.keys(data).reduce(function (result, key) {
        if (!result && key !== 'set' && key !== 'add') {
            return new Error('Data should be categorized into either "set" or "add"\n                in #send');
        }
        return result;
    }, null);

    if (error) {
        next(error);
        return;
    }

    if (typeof next === 'function') {
        var sentListener = function sentListener(evt) {
            if (evt.data.adpEventName !== 'seshat-sent') {
                return;
            }
            window.removeEventListener('message', sentListener);
            next(error);
        };
        window.addEventListener('message', sentListener);
    }
    error = sendEvent('seshat-send', data);
}

/**
 * Used in single-page applications to track a virtual pageload event (i.e. call
 * this if the URL changes without an explicit pageload).
 *
 * Precondition: adplogger is or will be initialized
 * Side effect: Track virtual pageload in adplogger
 *
 * @example
 * // Our single-page application has presented a new page for the user
 * adplogger.pageview({
 *   something: 'dark',
 *   other: 'side'
 * }, function (error) {
 *   if (error) {
 *      console.error('Failed to create pageview:', error);
 *   }
 * });
 *
 * @param {Object.<string, (number|string|boolean)>} metadata
 *      The metadata to include on subsequent requests
 * @param {Function=} next The function call to return
 */
function pageview(metadata) {
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    if (!initialized) {
        onAliveWrapper(pageview.bind(null, metadata, next), next);
        return;
    }

    var error = sendEvent('seshat-pageview', { metadata: metadata });
    next(error);
}

/**
 * Used on frontpages to log which teaser-test-variants are displayed to the user.
 *
 * @param {string} siteId The ID of the current frontpage as required by the test-processor
 * @param {...string[]} variantData 3-element array conaining `[teaserId, position, variant]`
 *                                  as strings
 * @param {Function=} next the last element can be a callback.
 *                         callback will be passed a parameter which is null (everything OK)
 *                         or a single error
 *                         or an array of nulls and/or errors where the position of errors
 *                         correlates to the order of variants
 *
 *
 * @example
 *
 * //setting siteId and adding variant data for multiple teasers
 * adplogger.variant('ABC123DEF456', ['5-41-1', 'spot3-2', 'A'],
 *                                   ['5-41-2', 'spot3-3', 'B'], (err) => {
 *   if (err) {
 *     console.error("could not add variants to log-stack")
 *     if (typeof err === 'array') {
 *        console.log("variant [5-41-1, spot3-2, A] resulted in ",err[0]);
 *        console.log("variant [5-41-2, spot3-3, B] resulted in ",err[1]);
 *     } else {
 *        console.log("the error was: ", err);
 *     }
 *   }
 * });
 *
 */
function variant() {
    // helper function for returning errors
    function err(msg, next) {
        var e = new Error(msg);next(e);return e;
    }

    var next = noop;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    var n = args.length;
    if (typeof args[n - 1] === 'function') {
        next = args[n - 1]; // last arg is next
        args.pop(); // remove last element
        n = args.length;
    }
    if (n < 2) {
        return err('not enough arguments.', next);
    }

    // function to recursively "add" variants
    function recAdd(variants, testId, results) {
        if (variants.length > 0) {
            var jsonVariant = void 0;
            try {
                var v = variants.shift(); // take next variant from list of variants
                v.unshift(testId); // splice testId onto front of variant-array
                jsonVariant = JSON.stringify(v);
            } catch (e) {
                next(e);
                return;
            }
            add({ adp_variant_view: jsonVariant }, function (error) {
                // collect results in array
                results.push(error);
                recAdd(variants, testId, results);
            });
            // call callback with results array or null if all results are null
        } else if (results.every(function (e) {
            return e === null;
        })) {
            next(null);
        } else {
            next(results);
        }
    }

    var firstArg = args[0];
    if (typeof firstArg === 'string') {
        args.shift(); // remove first element. now args should only contain variants
        recAdd(args, firstArg, []);
    } else {
        return err('first argument must be siteId (string)', next);
    }
    return null;
}

/**
 * Precondition: adplogger is or will be initialized
 * Side effect: Send player and events for logging when adplogger is loaded
 *
 * Specifically for logging a Flow Player 8 video
 * @see https://flowplayer.com/help/player/player-api
 * 
 * @example
 * // We want to log a video
 * adplogger.logVideo(player, flowplayer.events, flowplayer.adEvents)
 *
 * @param {Object} player initialized flow player
 * @param {Object} events built-in flow player events
 * @param {Object} adEvents events from ad plugin. optional.
 * @param {Object} qulEvents events from qul plugin. optional.
 */
function logVideo(player, events, adEvents, qulEvents) {
    function logger(e) {
        var loggerFunction = e.detail;
        loggerFunction(player, events, adEvents, qulEvents);
        window.removeEventListener('video.adplogger.live', logger);
    }
    window.addEventListener('video.adplogger.live', logger);
    window.dispatchEvent(new CustomEvent('video.adp.client.ready'));
}

var bin = {
    sendEvent: sendEvent,
    setLoggerWindow: setLoggerWindow,
    onAlive: onAlive,
    initialize: initialize,
    add: add,
    set: set,
    send: send,
    pageview: pageview,
    variant: variant,
    logVideo: logVideo
};

/* eslint-env browser */

const adplogger = bin;

const customElementName = 'amedia-scrollytelling';

function measureScroll(element) {
  const boundingClientRect = element.getBoundingClientRect();
  const { top, height } = boundingClientRect;
  const childCount = element.children.length;
  let frameHeight = window.innerHeight;

  if (childCount > 1) {
    frameHeight = height / (childCount - 1);
  }

  const adjustedTop = 1 - (top - frameHeight);
  const adjustedHeight = height + frameHeight;
  const embedProgress = (100 * adjustedTop) / adjustedHeight;

  const frameIndex = Math.floor(adjustedTop / frameHeight);
  const frameTop = adjustedTop % frameHeight;
  const frameProgress = (100 * frameTop) / frameHeight;

  return {
    embedProgress,
    frameIndex,
    frameProgress,
  };
}

function checkIntersection(entries) {
  entries.forEach((entry) => {
    const mediaId = entry.target.getAttribute('data-scrollytelling-media');
    const media = this.querySelector(`#scrollytelling-media-${mediaId}`);

    // const toggle = !(entry.intersectionRatio <= 0 && media.nextElementSibling);
    const toggle = !(entry.intersectionRatio <= 0);

    media.classList.toggle('visible', toggle);
    media.classList.toggle('hidden', false);

    if (media.getAttribute('videoId')) {
      const video = media.getElementsByTagName('video')[0];

      if (video) {
        video.classList.toggle('playing', toggle);
        video.classList.toggle('hidden', false);

        if (toggle) {
          video.play();
        } else {
          video.pause();
        }
      }
    }

    if (media.getAttribute('smartEmbedUrl')) {
      let activeFrame = false;

      const handleScroll = () => {
        const { embedProgress, frameIndex, frameProgress } = measureScroll(
          entry.target
        );

        if (embedProgress < 0 && embedProgress > 100.0001) {
          activeFrame = false;
        } else {
          const embedProgressEvent = new CustomEvent('embedProgress', {
            detail: {
              embedProgress,
              frameIndex,
              frameProgress,
            },
          });

          const frameProgressEvent = new CustomEvent('frameProgress', {
            detail: {
              frameIndex,
              frameProgress,
            },
          });

          media.dispatchEvent(embedProgressEvent);
          media.dispatchEvent(frameProgressEvent);

          if (frameIndex !== activeFrame) {
            const frameIndexEvent = new CustomEvent('frameIndex', {
              detail: {
                frameIndex,
                frameProgress,
              },
            });
            media.dispatchEvent(frameIndexEvent);
            activeFrame = frameIndex;
          }
        }
      };

      if (toggle) {
        const startEmbed = new CustomEvent('showEmbed', {
          detail: {
            url: media.getAttribute('smartEmbedUrl'),
          },
        });

        media.dispatchEvent(startEmbed);
        window.addEventListener('scroll', handleScroll, { passive: true });
      } else {
        const endEmbed = new CustomEvent('hideEmbed', {
          detail: {
            url: media.getAttribute('smartEmbedUrl'),
          },
        });

        media.dispatchEvent(endEmbed);
        window.removeEventListener('scroll', handleScroll, { passive: true });
      }
    }
  });
}

function customElementLogger(entries) {
  entries.forEach((entry) => {
    const contentId = this.getAttribute('content-id');

    if (entry.isIntersecting) {
      adplogger.add({ a_scrollytelling_enter: contentId });
    } else {
      adplogger.add({ a_scrollytelling_leave: contentId });
    }
  });
}

function slideLogger(entries) {
  entries.forEach((entry) => {
    const contentId = this.getAttribute('content-id');
    const indexId = entry.target.getAttribute('data-scrollytelling-index');

    if (entry.isIntersecting) {
      adplogger.add({
        a_scrollytelling_slide_enter: `${contentId}_${indexId}`,
      });
    }
  });
}

class AmediaScrollytelling extends HTMLElement {
  init() {
    this.createObserver();
    this.setupLogging();

    adplogger.add({ a_scrollytelling_id: this.getAttribute('content-id') });
  }

  createObserver() {
    const options = {
      rootMargin: '0px 0px 100%',
      threshold: [0],
    };

    const intersectionObserver = new IntersectionObserver(
      checkIntersection.bind(this),
      options
    );
    const textContainers = [
      ...this.getElementsByClassName('scrollytelling-text-container'),
    ];
    textContainers.forEach((element) => intersectionObserver.observe(element));
  }

  setupCustomElementLogger() {
    const options = {
      rootMargin: '0px 0px 0px',
      threshold: [0],
    };

    const intersectionObserver = new IntersectionObserver(
      customElementLogger.bind(this),
      options
    );
    const elements = [...this.getElementsByClassName('scrollytelling')];
    elements.forEach((element) => intersectionObserver.observe(element));
  }

  setupSlideLogger() {
    const options = {
      rootMargin: '0px 0px 0px',
      threshold: [0],
    };

    const intersectionObserver = new IntersectionObserver(
      slideLogger.bind(this),
      options
    );
    const slides = [
      ...this.getElementsByClassName('scrollytelling-text-container'),
    ];
    slides.forEach((element) => intersectionObserver.observe(element));
  }

  setupLogging() {
    this.setupCustomElementLogger();
    this.setupSlideLogger();
  }

  attachedCallback() {
    this.init();
  }

  connectedCallback() {
    this.init();
  }
}

if (customElements && customElements.define) {
  customElements.define(customElementName, AmediaScrollytelling);
} else {
  document.registerElement(customElementName, {
    prototype: AmediaScrollytelling.prototype,
  });
}

export { scrollytelling_browser as default };
